// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_DCDRFLATBUFFERS_DCDR_INTERCONNECT_DCDRFLATBUFFERS_H_
#define FLATBUFFERS_GENERATED_DCDRFLATBUFFERS_DCDR_INTERCONNECT_DCDRFLATBUFFERS_H_

#include "flatbuffers/flatbuffers.h"

namespace Dcdr {
namespace Interconnect {
namespace DcdrFlatBuffers {

struct Vec3;

struct Pixel;

struct ChunkInfo;

struct Chunk;

struct ChunkTask;

struct ConnectRequestData;

struct DisconnectRequestData;

struct GetSceneInfoRequestData;

struct VerifySceneRequestData;

struct GetWorkScopeRequestData;

struct PublishArtifactsRequestData;

struct Request;

struct ErrorResponseData;

struct ConnectResponseData;

struct DisconnectResponseData;

struct GetSceneInfoResponseData;

struct VerifySceneResponseData;

struct GetWorkScopeResponseData;

struct PublishArtifactsResponseData;

struct Response;

enum RequestData {
  RequestData_NONE = 0,
  RequestData_ConnectRequestData = 1,
  RequestData_DisconnectRequestData = 2,
  RequestData_GetSceneInfoRequestData = 3,
  RequestData_VerifySceneRequestData = 4,
  RequestData_GetWorkScopeRequestData = 5,
  RequestData_PublishArtifactsRequestData = 6,
  RequestData_MIN = RequestData_NONE,
  RequestData_MAX = RequestData_PublishArtifactsRequestData
};

inline RequestData (&EnumValuesRequestData())[7] {
  static RequestData values[] = {
    RequestData_NONE,
    RequestData_ConnectRequestData,
    RequestData_DisconnectRequestData,
    RequestData_GetSceneInfoRequestData,
    RequestData_VerifySceneRequestData,
    RequestData_GetWorkScopeRequestData,
    RequestData_PublishArtifactsRequestData
  };
  return values;
}

inline const char **EnumNamesRequestData() {
  static const char *names[] = {
    "NONE",
    "ConnectRequestData",
    "DisconnectRequestData",
    "GetSceneInfoRequestData",
    "VerifySceneRequestData",
    "GetWorkScopeRequestData",
    "PublishArtifactsRequestData",
    nullptr
  };
  return names;
}

inline const char *EnumNameRequestData(RequestData e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesRequestData()[index];
}

template<typename T> struct RequestDataTraits {
  static const RequestData enum_value = RequestData_NONE;
};

template<> struct RequestDataTraits<ConnectRequestData> {
  static const RequestData enum_value = RequestData_ConnectRequestData;
};

template<> struct RequestDataTraits<DisconnectRequestData> {
  static const RequestData enum_value = RequestData_DisconnectRequestData;
};

template<> struct RequestDataTraits<GetSceneInfoRequestData> {
  static const RequestData enum_value = RequestData_GetSceneInfoRequestData;
};

template<> struct RequestDataTraits<VerifySceneRequestData> {
  static const RequestData enum_value = RequestData_VerifySceneRequestData;
};

template<> struct RequestDataTraits<GetWorkScopeRequestData> {
  static const RequestData enum_value = RequestData_GetWorkScopeRequestData;
};

template<> struct RequestDataTraits<PublishArtifactsRequestData> {
  static const RequestData enum_value = RequestData_PublishArtifactsRequestData;
};

bool VerifyRequestData(flatbuffers::Verifier &verifier, const void *obj, RequestData type);
bool VerifyRequestDataVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

enum ResponseData {
  ResponseData_NONE = 0,
  ResponseData_ErrorResponseData = 1,
  ResponseData_ConnectResponseData = 2,
  ResponseData_DisconnectResponseData = 3,
  ResponseData_GetSceneInfoResponseData = 4,
  ResponseData_VerifySceneResponseData = 5,
  ResponseData_GetWorkScopeResponseData = 6,
  ResponseData_PublishArtifactsResponseData = 7,
  ResponseData_MIN = ResponseData_NONE,
  ResponseData_MAX = ResponseData_PublishArtifactsResponseData
};

inline ResponseData (&EnumValuesResponseData())[8] {
  static ResponseData values[] = {
    ResponseData_NONE,
    ResponseData_ErrorResponseData,
    ResponseData_ConnectResponseData,
    ResponseData_DisconnectResponseData,
    ResponseData_GetSceneInfoResponseData,
    ResponseData_VerifySceneResponseData,
    ResponseData_GetWorkScopeResponseData,
    ResponseData_PublishArtifactsResponseData
  };
  return values;
}

inline const char **EnumNamesResponseData() {
  static const char *names[] = {
    "NONE",
    "ErrorResponseData",
    "ConnectResponseData",
    "DisconnectResponseData",
    "GetSceneInfoResponseData",
    "VerifySceneResponseData",
    "GetWorkScopeResponseData",
    "PublishArtifactsResponseData",
    nullptr
  };
  return names;
}

inline const char *EnumNameResponseData(ResponseData e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesResponseData()[index];
}

template<typename T> struct ResponseDataTraits {
  static const ResponseData enum_value = ResponseData_NONE;
};

template<> struct ResponseDataTraits<ErrorResponseData> {
  static const ResponseData enum_value = ResponseData_ErrorResponseData;
};

template<> struct ResponseDataTraits<ConnectResponseData> {
  static const ResponseData enum_value = ResponseData_ConnectResponseData;
};

template<> struct ResponseDataTraits<DisconnectResponseData> {
  static const ResponseData enum_value = ResponseData_DisconnectResponseData;
};

template<> struct ResponseDataTraits<GetSceneInfoResponseData> {
  static const ResponseData enum_value = ResponseData_GetSceneInfoResponseData;
};

template<> struct ResponseDataTraits<VerifySceneResponseData> {
  static const ResponseData enum_value = ResponseData_VerifySceneResponseData;
};

template<> struct ResponseDataTraits<GetWorkScopeResponseData> {
  static const ResponseData enum_value = ResponseData_GetWorkScopeResponseData;
};

template<> struct ResponseDataTraits<PublishArtifactsResponseData> {
  static const ResponseData enum_value = ResponseData_PublishArtifactsResponseData;
};

bool VerifyResponseData(flatbuffers::Verifier &verifier, const void *obj, ResponseData type);
bool VerifyResponseDataVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

struct Vec3 FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_X = 4,
    VT_Y = 6,
    VT_Z = 8
  };
  float x() const {
    return GetField<float>(VT_X, 0.0f);
  }
  float y() const {
    return GetField<float>(VT_Y, 0.0f);
  }
  float z() const {
    return GetField<float>(VT_Z, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_X) &&
           VerifyField<float>(verifier, VT_Y) &&
           VerifyField<float>(verifier, VT_Z) &&
           verifier.EndTable();
  }
};

struct Vec3Builder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_x(float x) {
    fbb_.AddElement<float>(Vec3::VT_X, x, 0.0f);
  }
  void add_y(float y) {
    fbb_.AddElement<float>(Vec3::VT_Y, y, 0.0f);
  }
  void add_z(float z) {
    fbb_.AddElement<float>(Vec3::VT_Z, z, 0.0f);
  }
  explicit Vec3Builder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  Vec3Builder &operator=(const Vec3Builder &);
  flatbuffers::Offset<Vec3> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Vec3>(end);
    return o;
  }
};

inline flatbuffers::Offset<Vec3> CreateVec3(
    flatbuffers::FlatBufferBuilder &_fbb,
    float x = 0.0f,
    float y = 0.0f,
    float z = 0.0f) {
  Vec3Builder builder_(_fbb);
  builder_.add_z(z);
  builder_.add_y(y);
  builder_.add_x(x);
  return builder_.Finish();
}

struct Pixel FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_COLOR = 4,
    VT_VARIANCE = 6,
    VT_SAMPLES = 8
  };
  const Vec3 *color() const {
    return GetPointer<const Vec3 *>(VT_COLOR);
  }
  const Vec3 *variance() const {
    return GetPointer<const Vec3 *>(VT_VARIANCE);
  }
  uint64_t samples() const {
    return GetField<uint64_t>(VT_SAMPLES, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_COLOR) &&
           verifier.VerifyTable(color()) &&
           VerifyOffset(verifier, VT_VARIANCE) &&
           verifier.VerifyTable(variance()) &&
           VerifyField<uint64_t>(verifier, VT_SAMPLES) &&
           verifier.EndTable();
  }
};

struct PixelBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_color(flatbuffers::Offset<Vec3> color) {
    fbb_.AddOffset(Pixel::VT_COLOR, color);
  }
  void add_variance(flatbuffers::Offset<Vec3> variance) {
    fbb_.AddOffset(Pixel::VT_VARIANCE, variance);
  }
  void add_samples(uint64_t samples) {
    fbb_.AddElement<uint64_t>(Pixel::VT_SAMPLES, samples, 0);
  }
  explicit PixelBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PixelBuilder &operator=(const PixelBuilder &);
  flatbuffers::Offset<Pixel> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Pixel>(end);
    return o;
  }
};

inline flatbuffers::Offset<Pixel> CreatePixel(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<Vec3> color = 0,
    flatbuffers::Offset<Vec3> variance = 0,
    uint64_t samples = 0) {
  PixelBuilder builder_(_fbb);
  builder_.add_samples(samples);
  builder_.add_variance(variance);
  builder_.add_color(color);
  return builder_.Finish();
}

struct ChunkInfo FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_X = 4,
    VT_Y = 6,
    VT_W = 8,
    VT_H = 10
  };
  uint16_t x() const {
    return GetField<uint16_t>(VT_X, 0);
  }
  uint16_t y() const {
    return GetField<uint16_t>(VT_Y, 0);
  }
  uint16_t w() const {
    return GetField<uint16_t>(VT_W, 0);
  }
  uint16_t h() const {
    return GetField<uint16_t>(VT_H, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_X) &&
           VerifyField<uint16_t>(verifier, VT_Y) &&
           VerifyField<uint16_t>(verifier, VT_W) &&
           VerifyField<uint16_t>(verifier, VT_H) &&
           verifier.EndTable();
  }
};

struct ChunkInfoBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_x(uint16_t x) {
    fbb_.AddElement<uint16_t>(ChunkInfo::VT_X, x, 0);
  }
  void add_y(uint16_t y) {
    fbb_.AddElement<uint16_t>(ChunkInfo::VT_Y, y, 0);
  }
  void add_w(uint16_t w) {
    fbb_.AddElement<uint16_t>(ChunkInfo::VT_W, w, 0);
  }
  void add_h(uint16_t h) {
    fbb_.AddElement<uint16_t>(ChunkInfo::VT_H, h, 0);
  }
  explicit ChunkInfoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ChunkInfoBuilder &operator=(const ChunkInfoBuilder &);
  flatbuffers::Offset<ChunkInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ChunkInfo>(end);
    return o;
  }
};

inline flatbuffers::Offset<ChunkInfo> CreateChunkInfo(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t x = 0,
    uint16_t y = 0,
    uint16_t w = 0,
    uint16_t h = 0) {
  ChunkInfoBuilder builder_(_fbb);
  builder_.add_h(h);
  builder_.add_w(w);
  builder_.add_y(y);
  builder_.add_x(x);
  return builder_.Finish();
}

struct Chunk FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_INFO = 4,
    VT_PIXELS = 6
  };
  const ChunkInfo *info() const {
    return GetPointer<const ChunkInfo *>(VT_INFO);
  }
  const flatbuffers::Vector<flatbuffers::Offset<Pixel>> *pixels() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Pixel>> *>(VT_PIXELS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_INFO) &&
           verifier.VerifyTable(info()) &&
           VerifyOffset(verifier, VT_PIXELS) &&
           verifier.Verify(pixels()) &&
           verifier.VerifyVectorOfTables(pixels()) &&
           verifier.EndTable();
  }
};

struct ChunkBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_info(flatbuffers::Offset<ChunkInfo> info) {
    fbb_.AddOffset(Chunk::VT_INFO, info);
  }
  void add_pixels(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Pixel>>> pixels) {
    fbb_.AddOffset(Chunk::VT_PIXELS, pixels);
  }
  explicit ChunkBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ChunkBuilder &operator=(const ChunkBuilder &);
  flatbuffers::Offset<Chunk> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Chunk>(end);
    return o;
  }
};

inline flatbuffers::Offset<Chunk> CreateChunk(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<ChunkInfo> info = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Pixel>>> pixels = 0) {
  ChunkBuilder builder_(_fbb);
  builder_.add_pixels(pixels);
  builder_.add_info(info);
  return builder_.Finish();
}

inline flatbuffers::Offset<Chunk> CreateChunkDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<ChunkInfo> info = 0,
    const std::vector<flatbuffers::Offset<Pixel>> *pixels = nullptr) {
  return Dcdr::Interconnect::DcdrFlatBuffers::CreateChunk(
      _fbb,
      info,
      pixels ? _fbb.CreateVector<flatbuffers::Offset<Pixel>>(*pixels) : 0);
}

struct ChunkTask FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_CHUNK = 4,
    VT_ITERATIONS = 6
  };
  const ChunkInfo *chunk() const {
    return GetPointer<const ChunkInfo *>(VT_CHUNK);
  }
  uint32_t iterations() const {
    return GetField<uint32_t>(VT_ITERATIONS, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_CHUNK) &&
           verifier.VerifyTable(chunk()) &&
           VerifyField<uint32_t>(verifier, VT_ITERATIONS) &&
           verifier.EndTable();
  }
};

struct ChunkTaskBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_chunk(flatbuffers::Offset<ChunkInfo> chunk) {
    fbb_.AddOffset(ChunkTask::VT_CHUNK, chunk);
  }
  void add_iterations(uint32_t iterations) {
    fbb_.AddElement<uint32_t>(ChunkTask::VT_ITERATIONS, iterations, 0);
  }
  explicit ChunkTaskBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ChunkTaskBuilder &operator=(const ChunkTaskBuilder &);
  flatbuffers::Offset<ChunkTask> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ChunkTask>(end);
    return o;
  }
};

inline flatbuffers::Offset<ChunkTask> CreateChunkTask(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<ChunkInfo> chunk = 0,
    uint32_t iterations = 0) {
  ChunkTaskBuilder builder_(_fbb);
  builder_.add_iterations(iterations);
  builder_.add_chunk(chunk);
  return builder_.Finish();
}

struct ConnectRequestData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_USERTOKEN = 4
  };
  const flatbuffers::String *userToken() const {
    return GetPointer<const flatbuffers::String *>(VT_USERTOKEN);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_USERTOKEN) &&
           verifier.Verify(userToken()) &&
           verifier.EndTable();
  }
};

struct ConnectRequestDataBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_userToken(flatbuffers::Offset<flatbuffers::String> userToken) {
    fbb_.AddOffset(ConnectRequestData::VT_USERTOKEN, userToken);
  }
  explicit ConnectRequestDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ConnectRequestDataBuilder &operator=(const ConnectRequestDataBuilder &);
  flatbuffers::Offset<ConnectRequestData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ConnectRequestData>(end);
    return o;
  }
};

inline flatbuffers::Offset<ConnectRequestData> CreateConnectRequestData(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> userToken = 0) {
  ConnectRequestDataBuilder builder_(_fbb);
  builder_.add_userToken(userToken);
  return builder_.Finish();
}

inline flatbuffers::Offset<ConnectRequestData> CreateConnectRequestDataDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *userToken = nullptr) {
  return Dcdr::Interconnect::DcdrFlatBuffers::CreateConnectRequestData(
      _fbb,
      userToken ? _fbb.CreateString(userToken) : 0);
}

struct DisconnectRequestData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct DisconnectRequestDataBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit DisconnectRequestDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DisconnectRequestDataBuilder &operator=(const DisconnectRequestDataBuilder &);
  flatbuffers::Offset<DisconnectRequestData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DisconnectRequestData>(end);
    return o;
  }
};

inline flatbuffers::Offset<DisconnectRequestData> CreateDisconnectRequestData(
    flatbuffers::FlatBufferBuilder &_fbb) {
  DisconnectRequestDataBuilder builder_(_fbb);
  return builder_.Finish();
}

struct GetSceneInfoRequestData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct GetSceneInfoRequestDataBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit GetSceneInfoRequestDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GetSceneInfoRequestDataBuilder &operator=(const GetSceneInfoRequestDataBuilder &);
  flatbuffers::Offset<GetSceneInfoRequestData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GetSceneInfoRequestData>(end);
    return o;
  }
};

inline flatbuffers::Offset<GetSceneInfoRequestData> CreateGetSceneInfoRequestData(
    flatbuffers::FlatBufferBuilder &_fbb) {
  GetSceneInfoRequestDataBuilder builder_(_fbb);
  return builder_.Finish();
}

struct VerifySceneRequestData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_SCENEMD5 = 4
  };
  const flatbuffers::String *sceneMD5() const {
    return GetPointer<const flatbuffers::String *>(VT_SCENEMD5);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_SCENEMD5) &&
           verifier.Verify(sceneMD5()) &&
           verifier.EndTable();
  }
};

struct VerifySceneRequestDataBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_sceneMD5(flatbuffers::Offset<flatbuffers::String> sceneMD5) {
    fbb_.AddOffset(VerifySceneRequestData::VT_SCENEMD5, sceneMD5);
  }
  explicit VerifySceneRequestDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  VerifySceneRequestDataBuilder &operator=(const VerifySceneRequestDataBuilder &);
  flatbuffers::Offset<VerifySceneRequestData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<VerifySceneRequestData>(end);
    return o;
  }
};

inline flatbuffers::Offset<VerifySceneRequestData> CreateVerifySceneRequestData(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> sceneMD5 = 0) {
  VerifySceneRequestDataBuilder builder_(_fbb);
  builder_.add_sceneMD5(sceneMD5);
  return builder_.Finish();
}

inline flatbuffers::Offset<VerifySceneRequestData> CreateVerifySceneRequestDataDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *sceneMD5 = nullptr) {
  return Dcdr::Interconnect::DcdrFlatBuffers::CreateVerifySceneRequestData(
      _fbb,
      sceneMD5 ? _fbb.CreateString(sceneMD5) : 0);
}

struct GetWorkScopeRequestData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_THREADSAVAILABLE = 4
  };
  uint16_t threadsAvailable() const {
    return GetField<uint16_t>(VT_THREADSAVAILABLE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_THREADSAVAILABLE) &&
           verifier.EndTable();
  }
};

struct GetWorkScopeRequestDataBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_threadsAvailable(uint16_t threadsAvailable) {
    fbb_.AddElement<uint16_t>(GetWorkScopeRequestData::VT_THREADSAVAILABLE, threadsAvailable, 0);
  }
  explicit GetWorkScopeRequestDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GetWorkScopeRequestDataBuilder &operator=(const GetWorkScopeRequestDataBuilder &);
  flatbuffers::Offset<GetWorkScopeRequestData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GetWorkScopeRequestData>(end);
    return o;
  }
};

inline flatbuffers::Offset<GetWorkScopeRequestData> CreateGetWorkScopeRequestData(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t threadsAvailable = 0) {
  GetWorkScopeRequestDataBuilder builder_(_fbb);
  builder_.add_threadsAvailable(threadsAvailable);
  return builder_.Finish();
}

struct PublishArtifactsRequestData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_CHUNKS = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<Chunk>> *chunks() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Chunk>> *>(VT_CHUNKS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_CHUNKS) &&
           verifier.Verify(chunks()) &&
           verifier.VerifyVectorOfTables(chunks()) &&
           verifier.EndTable();
  }
};

struct PublishArtifactsRequestDataBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_chunks(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Chunk>>> chunks) {
    fbb_.AddOffset(PublishArtifactsRequestData::VT_CHUNKS, chunks);
  }
  explicit PublishArtifactsRequestDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PublishArtifactsRequestDataBuilder &operator=(const PublishArtifactsRequestDataBuilder &);
  flatbuffers::Offset<PublishArtifactsRequestData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PublishArtifactsRequestData>(end);
    return o;
  }
};

inline flatbuffers::Offset<PublishArtifactsRequestData> CreatePublishArtifactsRequestData(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Chunk>>> chunks = 0) {
  PublishArtifactsRequestDataBuilder builder_(_fbb);
  builder_.add_chunks(chunks);
  return builder_.Finish();
}

inline flatbuffers::Offset<PublishArtifactsRequestData> CreatePublishArtifactsRequestDataDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<Chunk>> *chunks = nullptr) {
  return Dcdr::Interconnect::DcdrFlatBuffers::CreatePublishArtifactsRequestData(
      _fbb,
      chunks ? _fbb.CreateVector<flatbuffers::Offset<Chunk>>(*chunks) : 0);
}

struct Request FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_CONNECTIONID = 4,
    VT_REQUESTDATA_TYPE = 6,
    VT_REQUESTDATA = 8
  };
  const flatbuffers::Vector<uint8_t> *connectionId() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_CONNECTIONID);
  }
  RequestData requestData_type() const {
    return static_cast<RequestData>(GetField<uint8_t>(VT_REQUESTDATA_TYPE, 0));
  }
  const void *requestData() const {
    return GetPointer<const void *>(VT_REQUESTDATA);
  }
  template<typename T> const T *requestData_as() const;
  const ConnectRequestData *requestData_as_ConnectRequestData() const {
    return requestData_type() == RequestData_ConnectRequestData ? static_cast<const ConnectRequestData *>(requestData()) : nullptr;
  }
  const DisconnectRequestData *requestData_as_DisconnectRequestData() const {
    return requestData_type() == RequestData_DisconnectRequestData ? static_cast<const DisconnectRequestData *>(requestData()) : nullptr;
  }
  const GetSceneInfoRequestData *requestData_as_GetSceneInfoRequestData() const {
    return requestData_type() == RequestData_GetSceneInfoRequestData ? static_cast<const GetSceneInfoRequestData *>(requestData()) : nullptr;
  }
  const VerifySceneRequestData *requestData_as_VerifySceneRequestData() const {
    return requestData_type() == RequestData_VerifySceneRequestData ? static_cast<const VerifySceneRequestData *>(requestData()) : nullptr;
  }
  const GetWorkScopeRequestData *requestData_as_GetWorkScopeRequestData() const {
    return requestData_type() == RequestData_GetWorkScopeRequestData ? static_cast<const GetWorkScopeRequestData *>(requestData()) : nullptr;
  }
  const PublishArtifactsRequestData *requestData_as_PublishArtifactsRequestData() const {
    return requestData_type() == RequestData_PublishArtifactsRequestData ? static_cast<const PublishArtifactsRequestData *>(requestData()) : nullptr;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_CONNECTIONID) &&
           verifier.Verify(connectionId()) &&
           VerifyField<uint8_t>(verifier, VT_REQUESTDATA_TYPE) &&
           VerifyOffset(verifier, VT_REQUESTDATA) &&
           VerifyRequestData(verifier, requestData(), requestData_type()) &&
           verifier.EndTable();
  }
};

template<> inline const ConnectRequestData *Request::requestData_as<ConnectRequestData>() const {
  return requestData_as_ConnectRequestData();
}

template<> inline const DisconnectRequestData *Request::requestData_as<DisconnectRequestData>() const {
  return requestData_as_DisconnectRequestData();
}

template<> inline const GetSceneInfoRequestData *Request::requestData_as<GetSceneInfoRequestData>() const {
  return requestData_as_GetSceneInfoRequestData();
}

template<> inline const VerifySceneRequestData *Request::requestData_as<VerifySceneRequestData>() const {
  return requestData_as_VerifySceneRequestData();
}

template<> inline const GetWorkScopeRequestData *Request::requestData_as<GetWorkScopeRequestData>() const {
  return requestData_as_GetWorkScopeRequestData();
}

template<> inline const PublishArtifactsRequestData *Request::requestData_as<PublishArtifactsRequestData>() const {
  return requestData_as_PublishArtifactsRequestData();
}

struct RequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_connectionId(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> connectionId) {
    fbb_.AddOffset(Request::VT_CONNECTIONID, connectionId);
  }
  void add_requestData_type(RequestData requestData_type) {
    fbb_.AddElement<uint8_t>(Request::VT_REQUESTDATA_TYPE, static_cast<uint8_t>(requestData_type), 0);
  }
  void add_requestData(flatbuffers::Offset<void> requestData) {
    fbb_.AddOffset(Request::VT_REQUESTDATA, requestData);
  }
  explicit RequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  RequestBuilder &operator=(const RequestBuilder &);
  flatbuffers::Offset<Request> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Request>(end);
    return o;
  }
};

inline flatbuffers::Offset<Request> CreateRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> connectionId = 0,
    RequestData requestData_type = RequestData_NONE,
    flatbuffers::Offset<void> requestData = 0) {
  RequestBuilder builder_(_fbb);
  builder_.add_requestData(requestData);
  builder_.add_connectionId(connectionId);
  builder_.add_requestData_type(requestData_type);
  return builder_.Finish();
}

inline flatbuffers::Offset<Request> CreateRequestDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint8_t> *connectionId = nullptr,
    RequestData requestData_type = RequestData_NONE,
    flatbuffers::Offset<void> requestData = 0) {
  return Dcdr::Interconnect::DcdrFlatBuffers::CreateRequest(
      _fbb,
      connectionId ? _fbb.CreateVector<uint8_t>(*connectionId) : 0,
      requestData_type,
      requestData);
}

struct ErrorResponseData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_CAUSE = 4
  };
  const flatbuffers::String *cause() const {
    return GetPointer<const flatbuffers::String *>(VT_CAUSE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_CAUSE) &&
           verifier.Verify(cause()) &&
           verifier.EndTable();
  }
};

struct ErrorResponseDataBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_cause(flatbuffers::Offset<flatbuffers::String> cause) {
    fbb_.AddOffset(ErrorResponseData::VT_CAUSE, cause);
  }
  explicit ErrorResponseDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ErrorResponseDataBuilder &operator=(const ErrorResponseDataBuilder &);
  flatbuffers::Offset<ErrorResponseData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ErrorResponseData>(end);
    return o;
  }
};

inline flatbuffers::Offset<ErrorResponseData> CreateErrorResponseData(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> cause = 0) {
  ErrorResponseDataBuilder builder_(_fbb);
  builder_.add_cause(cause);
  return builder_.Finish();
}

inline flatbuffers::Offset<ErrorResponseData> CreateErrorResponseDataDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *cause = nullptr) {
  return Dcdr::Interconnect::DcdrFlatBuffers::CreateErrorResponseData(
      _fbb,
      cause ? _fbb.CreateString(cause) : 0);
}

struct ConnectResponseData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_CONNECTIONID = 4
  };
  const flatbuffers::Vector<uint8_t> *connectionId() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_CONNECTIONID);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_CONNECTIONID) &&
           verifier.Verify(connectionId()) &&
           verifier.EndTable();
  }
};

struct ConnectResponseDataBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_connectionId(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> connectionId) {
    fbb_.AddOffset(ConnectResponseData::VT_CONNECTIONID, connectionId);
  }
  explicit ConnectResponseDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ConnectResponseDataBuilder &operator=(const ConnectResponseDataBuilder &);
  flatbuffers::Offset<ConnectResponseData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ConnectResponseData>(end);
    return o;
  }
};

inline flatbuffers::Offset<ConnectResponseData> CreateConnectResponseData(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> connectionId = 0) {
  ConnectResponseDataBuilder builder_(_fbb);
  builder_.add_connectionId(connectionId);
  return builder_.Finish();
}

inline flatbuffers::Offset<ConnectResponseData> CreateConnectResponseDataDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint8_t> *connectionId = nullptr) {
  return Dcdr::Interconnect::DcdrFlatBuffers::CreateConnectResponseData(
      _fbb,
      connectionId ? _fbb.CreateVector<uint8_t>(*connectionId) : 0);
}

struct DisconnectResponseData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct DisconnectResponseDataBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit DisconnectResponseDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DisconnectResponseDataBuilder &operator=(const DisconnectResponseDataBuilder &);
  flatbuffers::Offset<DisconnectResponseData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DisconnectResponseData>(end);
    return o;
  }
};

inline flatbuffers::Offset<DisconnectResponseData> CreateDisconnectResponseData(
    flatbuffers::FlatBufferBuilder &_fbb) {
  DisconnectResponseDataBuilder builder_(_fbb);
  return builder_.Finish();
}

struct GetSceneInfoResponseData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_SCENEID = 4
  };
  const flatbuffers::String *sceneId() const {
    return GetPointer<const flatbuffers::String *>(VT_SCENEID);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_SCENEID) &&
           verifier.Verify(sceneId()) &&
           verifier.EndTable();
  }
};

struct GetSceneInfoResponseDataBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_sceneId(flatbuffers::Offset<flatbuffers::String> sceneId) {
    fbb_.AddOffset(GetSceneInfoResponseData::VT_SCENEID, sceneId);
  }
  explicit GetSceneInfoResponseDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GetSceneInfoResponseDataBuilder &operator=(const GetSceneInfoResponseDataBuilder &);
  flatbuffers::Offset<GetSceneInfoResponseData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GetSceneInfoResponseData>(end);
    return o;
  }
};

inline flatbuffers::Offset<GetSceneInfoResponseData> CreateGetSceneInfoResponseData(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> sceneId = 0) {
  GetSceneInfoResponseDataBuilder builder_(_fbb);
  builder_.add_sceneId(sceneId);
  return builder_.Finish();
}

inline flatbuffers::Offset<GetSceneInfoResponseData> CreateGetSceneInfoResponseDataDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *sceneId = nullptr) {
  return Dcdr::Interconnect::DcdrFlatBuffers::CreateGetSceneInfoResponseData(
      _fbb,
      sceneId ? _fbb.CreateString(sceneId) : 0);
}

struct VerifySceneResponseData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct VerifySceneResponseDataBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit VerifySceneResponseDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  VerifySceneResponseDataBuilder &operator=(const VerifySceneResponseDataBuilder &);
  flatbuffers::Offset<VerifySceneResponseData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<VerifySceneResponseData>(end);
    return o;
  }
};

inline flatbuffers::Offset<VerifySceneResponseData> CreateVerifySceneResponseData(
    flatbuffers::FlatBufferBuilder &_fbb) {
  VerifySceneResponseDataBuilder builder_(_fbb);
  return builder_.Finish();
}

struct GetWorkScopeResponseData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_TASKS = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<ChunkTask>> *tasks() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<ChunkTask>> *>(VT_TASKS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_TASKS) &&
           verifier.Verify(tasks()) &&
           verifier.VerifyVectorOfTables(tasks()) &&
           verifier.EndTable();
  }
};

struct GetWorkScopeResponseDataBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_tasks(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ChunkTask>>> tasks) {
    fbb_.AddOffset(GetWorkScopeResponseData::VT_TASKS, tasks);
  }
  explicit GetWorkScopeResponseDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GetWorkScopeResponseDataBuilder &operator=(const GetWorkScopeResponseDataBuilder &);
  flatbuffers::Offset<GetWorkScopeResponseData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GetWorkScopeResponseData>(end);
    return o;
  }
};

inline flatbuffers::Offset<GetWorkScopeResponseData> CreateGetWorkScopeResponseData(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ChunkTask>>> tasks = 0) {
  GetWorkScopeResponseDataBuilder builder_(_fbb);
  builder_.add_tasks(tasks);
  return builder_.Finish();
}

inline flatbuffers::Offset<GetWorkScopeResponseData> CreateGetWorkScopeResponseDataDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<ChunkTask>> *tasks = nullptr) {
  return Dcdr::Interconnect::DcdrFlatBuffers::CreateGetWorkScopeResponseData(
      _fbb,
      tasks ? _fbb.CreateVector<flatbuffers::Offset<ChunkTask>>(*tasks) : 0);
}

struct PublishArtifactsResponseData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct PublishArtifactsResponseDataBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit PublishArtifactsResponseDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PublishArtifactsResponseDataBuilder &operator=(const PublishArtifactsResponseDataBuilder &);
  flatbuffers::Offset<PublishArtifactsResponseData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PublishArtifactsResponseData>(end);
    return o;
  }
};

inline flatbuffers::Offset<PublishArtifactsResponseData> CreatePublishArtifactsResponseData(
    flatbuffers::FlatBufferBuilder &_fbb) {
  PublishArtifactsResponseDataBuilder builder_(_fbb);
  return builder_.Finish();
}

struct Response FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_SESSION = 4,
    VT_RESPONSEDATA_TYPE = 6,
    VT_RESPONSEDATA = 8
  };
  const flatbuffers::Vector<uint8_t> *session() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_SESSION);
  }
  ResponseData responseData_type() const {
    return static_cast<ResponseData>(GetField<uint8_t>(VT_RESPONSEDATA_TYPE, 0));
  }
  const void *responseData() const {
    return GetPointer<const void *>(VT_RESPONSEDATA);
  }
  template<typename T> const T *responseData_as() const;
  const ErrorResponseData *responseData_as_ErrorResponseData() const {
    return responseData_type() == ResponseData_ErrorResponseData ? static_cast<const ErrorResponseData *>(responseData()) : nullptr;
  }
  const ConnectResponseData *responseData_as_ConnectResponseData() const {
    return responseData_type() == ResponseData_ConnectResponseData ? static_cast<const ConnectResponseData *>(responseData()) : nullptr;
  }
  const DisconnectResponseData *responseData_as_DisconnectResponseData() const {
    return responseData_type() == ResponseData_DisconnectResponseData ? static_cast<const DisconnectResponseData *>(responseData()) : nullptr;
  }
  const GetSceneInfoResponseData *responseData_as_GetSceneInfoResponseData() const {
    return responseData_type() == ResponseData_GetSceneInfoResponseData ? static_cast<const GetSceneInfoResponseData *>(responseData()) : nullptr;
  }
  const VerifySceneResponseData *responseData_as_VerifySceneResponseData() const {
    return responseData_type() == ResponseData_VerifySceneResponseData ? static_cast<const VerifySceneResponseData *>(responseData()) : nullptr;
  }
  const GetWorkScopeResponseData *responseData_as_GetWorkScopeResponseData() const {
    return responseData_type() == ResponseData_GetWorkScopeResponseData ? static_cast<const GetWorkScopeResponseData *>(responseData()) : nullptr;
  }
  const PublishArtifactsResponseData *responseData_as_PublishArtifactsResponseData() const {
    return responseData_type() == ResponseData_PublishArtifactsResponseData ? static_cast<const PublishArtifactsResponseData *>(responseData()) : nullptr;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_SESSION) &&
           verifier.Verify(session()) &&
           VerifyField<uint8_t>(verifier, VT_RESPONSEDATA_TYPE) &&
           VerifyOffset(verifier, VT_RESPONSEDATA) &&
           VerifyResponseData(verifier, responseData(), responseData_type()) &&
           verifier.EndTable();
  }
};

template<> inline const ErrorResponseData *Response::responseData_as<ErrorResponseData>() const {
  return responseData_as_ErrorResponseData();
}

template<> inline const ConnectResponseData *Response::responseData_as<ConnectResponseData>() const {
  return responseData_as_ConnectResponseData();
}

template<> inline const DisconnectResponseData *Response::responseData_as<DisconnectResponseData>() const {
  return responseData_as_DisconnectResponseData();
}

template<> inline const GetSceneInfoResponseData *Response::responseData_as<GetSceneInfoResponseData>() const {
  return responseData_as_GetSceneInfoResponseData();
}

template<> inline const VerifySceneResponseData *Response::responseData_as<VerifySceneResponseData>() const {
  return responseData_as_VerifySceneResponseData();
}

template<> inline const GetWorkScopeResponseData *Response::responseData_as<GetWorkScopeResponseData>() const {
  return responseData_as_GetWorkScopeResponseData();
}

template<> inline const PublishArtifactsResponseData *Response::responseData_as<PublishArtifactsResponseData>() const {
  return responseData_as_PublishArtifactsResponseData();
}

struct ResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_session(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> session) {
    fbb_.AddOffset(Response::VT_SESSION, session);
  }
  void add_responseData_type(ResponseData responseData_type) {
    fbb_.AddElement<uint8_t>(Response::VT_RESPONSEDATA_TYPE, static_cast<uint8_t>(responseData_type), 0);
  }
  void add_responseData(flatbuffers::Offset<void> responseData) {
    fbb_.AddOffset(Response::VT_RESPONSEDATA, responseData);
  }
  explicit ResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ResponseBuilder &operator=(const ResponseBuilder &);
  flatbuffers::Offset<Response> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Response>(end);
    return o;
  }
};

inline flatbuffers::Offset<Response> CreateResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> session = 0,
    ResponseData responseData_type = ResponseData_NONE,
    flatbuffers::Offset<void> responseData = 0) {
  ResponseBuilder builder_(_fbb);
  builder_.add_responseData(responseData);
  builder_.add_session(session);
  builder_.add_responseData_type(responseData_type);
  return builder_.Finish();
}

inline flatbuffers::Offset<Response> CreateResponseDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint8_t> *session = nullptr,
    ResponseData responseData_type = ResponseData_NONE,
    flatbuffers::Offset<void> responseData = 0) {
  return Dcdr::Interconnect::DcdrFlatBuffers::CreateResponse(
      _fbb,
      session ? _fbb.CreateVector<uint8_t>(*session) : 0,
      responseData_type,
      responseData);
}

inline bool VerifyRequestData(flatbuffers::Verifier &verifier, const void *obj, RequestData type) {
  switch (type) {
    case RequestData_NONE: {
      return true;
    }
    case RequestData_ConnectRequestData: {
      auto ptr = reinterpret_cast<const ConnectRequestData *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case RequestData_DisconnectRequestData: {
      auto ptr = reinterpret_cast<const DisconnectRequestData *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case RequestData_GetSceneInfoRequestData: {
      auto ptr = reinterpret_cast<const GetSceneInfoRequestData *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case RequestData_VerifySceneRequestData: {
      auto ptr = reinterpret_cast<const VerifySceneRequestData *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case RequestData_GetWorkScopeRequestData: {
      auto ptr = reinterpret_cast<const GetWorkScopeRequestData *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case RequestData_PublishArtifactsRequestData: {
      auto ptr = reinterpret_cast<const PublishArtifactsRequestData *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return false;
  }
}

inline bool VerifyRequestDataVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyRequestData(
        verifier,  values->Get(i), types->GetEnum<RequestData>(i))) {
      return false;
    }
  }
  return true;
}

inline bool VerifyResponseData(flatbuffers::Verifier &verifier, const void *obj, ResponseData type) {
  switch (type) {
    case ResponseData_NONE: {
      return true;
    }
    case ResponseData_ErrorResponseData: {
      auto ptr = reinterpret_cast<const ErrorResponseData *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ResponseData_ConnectResponseData: {
      auto ptr = reinterpret_cast<const ConnectResponseData *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ResponseData_DisconnectResponseData: {
      auto ptr = reinterpret_cast<const DisconnectResponseData *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ResponseData_GetSceneInfoResponseData: {
      auto ptr = reinterpret_cast<const GetSceneInfoResponseData *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ResponseData_VerifySceneResponseData: {
      auto ptr = reinterpret_cast<const VerifySceneResponseData *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ResponseData_GetWorkScopeResponseData: {
      auto ptr = reinterpret_cast<const GetWorkScopeResponseData *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ResponseData_PublishArtifactsResponseData: {
      auto ptr = reinterpret_cast<const PublishArtifactsResponseData *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return false;
  }
}

inline bool VerifyResponseDataVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyResponseData(
        verifier,  values->Get(i), types->GetEnum<ResponseData>(i))) {
      return false;
    }
  }
  return true;
}

}  // namespace DcdrFlatBuffers
}  // namespace Interconnect
}  // namespace Dcdr

#endif  // FLATBUFFERS_GENERATED_DCDRFLATBUFFERS_DCDR_INTERCONNECT_DCDRFLATBUFFERS_H_
