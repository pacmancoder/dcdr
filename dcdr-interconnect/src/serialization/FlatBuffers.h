// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_DNCP_DCDR_INTERCONNECT_DCDRFLATBUFFERS_H_
#define FLATBUFFERS_GENERATED_DNCP_DCDR_INTERCONNECT_DCDRFLATBUFFERS_H_

#include "flatbuffers/flatbuffers.h"

namespace Dcdr {
namespace Interconnect {
namespace DcdrFlatBuffers {

struct Vec3;

struct Pixel;

struct ChunkInfo;

struct Chunk;

struct ChunkTask;

struct WorkerConnectRequest;

struct WorkerDisconnectRequest;

struct WorkerGetSceneInfoRequest;

struct WorkerVerifySceneRequest;

struct WorkerGetWorkScopeRequest;

struct WorkerPublishArtifactsRequest;

struct WorkerRequest;

struct WorkerErrorResponse;

struct WorkerConnectResponse;

struct WorkerDisconnectResponse;

struct WorkerGetSceneInfoResponse;

struct WorkerVerifySceneResponse;

struct WorkerGetWorkScopeResponse;

struct WorkerPublishArtifactsResponse;

struct WorkerResponse;

struct CommanderGetSurfaceInfoRequest;

struct CommanderGetSurfaceRequest;

struct CommanderRequest;

struct CommanderGetSurfaceInfoResponse;

struct CommanderGetSurfaceResponse;

struct CommanderResponse;

struct Parcel;

enum WorkerRequestData {
  WorkerRequestData_NONE = 0,
  WorkerRequestData_WorkerConnectRequest = 1,
  WorkerRequestData_WorkerDisconnectRequest = 2,
  WorkerRequestData_WorkerGetSceneInfoRequest = 3,
  WorkerRequestData_WorkerVerifySceneRequest = 4,
  WorkerRequestData_WorkerGetWorkScopeRequest = 5,
  WorkerRequestData_WorkerPublishArtifactsRequest = 6,
  WorkerRequestData_MIN = WorkerRequestData_NONE,
  WorkerRequestData_MAX = WorkerRequestData_WorkerPublishArtifactsRequest
};

inline WorkerRequestData (&EnumValuesWorkerRequestData())[7] {
  static WorkerRequestData values[] = {
    WorkerRequestData_NONE,
    WorkerRequestData_WorkerConnectRequest,
    WorkerRequestData_WorkerDisconnectRequest,
    WorkerRequestData_WorkerGetSceneInfoRequest,
    WorkerRequestData_WorkerVerifySceneRequest,
    WorkerRequestData_WorkerGetWorkScopeRequest,
    WorkerRequestData_WorkerPublishArtifactsRequest
  };
  return values;
}

inline const char **EnumNamesWorkerRequestData() {
  static const char *names[] = {
    "NONE",
    "WorkerConnectRequest",
    "WorkerDisconnectRequest",
    "WorkerGetSceneInfoRequest",
    "WorkerVerifySceneRequest",
    "WorkerGetWorkScopeRequest",
    "WorkerPublishArtifactsRequest",
    nullptr
  };
  return names;
}

inline const char *EnumNameWorkerRequestData(WorkerRequestData e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesWorkerRequestData()[index];
}

template<typename T> struct WorkerRequestDataTraits {
  static const WorkerRequestData enum_value = WorkerRequestData_NONE;
};

template<> struct WorkerRequestDataTraits<WorkerConnectRequest> {
  static const WorkerRequestData enum_value = WorkerRequestData_WorkerConnectRequest;
};

template<> struct WorkerRequestDataTraits<WorkerDisconnectRequest> {
  static const WorkerRequestData enum_value = WorkerRequestData_WorkerDisconnectRequest;
};

template<> struct WorkerRequestDataTraits<WorkerGetSceneInfoRequest> {
  static const WorkerRequestData enum_value = WorkerRequestData_WorkerGetSceneInfoRequest;
};

template<> struct WorkerRequestDataTraits<WorkerVerifySceneRequest> {
  static const WorkerRequestData enum_value = WorkerRequestData_WorkerVerifySceneRequest;
};

template<> struct WorkerRequestDataTraits<WorkerGetWorkScopeRequest> {
  static const WorkerRequestData enum_value = WorkerRequestData_WorkerGetWorkScopeRequest;
};

template<> struct WorkerRequestDataTraits<WorkerPublishArtifactsRequest> {
  static const WorkerRequestData enum_value = WorkerRequestData_WorkerPublishArtifactsRequest;
};

bool VerifyWorkerRequestData(flatbuffers::Verifier &verifier, const void *obj, WorkerRequestData type);
bool VerifyWorkerRequestDataVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

enum WorkerResponseData {
  WorkerResponseData_NONE = 0,
  WorkerResponseData_WorkerErrorResponse = 1,
  WorkerResponseData_WorkerConnectResponse = 2,
  WorkerResponseData_WorkerDisconnectResponse = 3,
  WorkerResponseData_WorkerGetSceneInfoResponse = 4,
  WorkerResponseData_WorkerVerifySceneResponse = 5,
  WorkerResponseData_WorkerGetWorkScopeResponse = 6,
  WorkerResponseData_WorkerPublishArtifactsResponse = 7,
  WorkerResponseData_MIN = WorkerResponseData_NONE,
  WorkerResponseData_MAX = WorkerResponseData_WorkerPublishArtifactsResponse
};

inline WorkerResponseData (&EnumValuesWorkerResponseData())[8] {
  static WorkerResponseData values[] = {
    WorkerResponseData_NONE,
    WorkerResponseData_WorkerErrorResponse,
    WorkerResponseData_WorkerConnectResponse,
    WorkerResponseData_WorkerDisconnectResponse,
    WorkerResponseData_WorkerGetSceneInfoResponse,
    WorkerResponseData_WorkerVerifySceneResponse,
    WorkerResponseData_WorkerGetWorkScopeResponse,
    WorkerResponseData_WorkerPublishArtifactsResponse
  };
  return values;
}

inline const char **EnumNamesWorkerResponseData() {
  static const char *names[] = {
    "NONE",
    "WorkerErrorResponse",
    "WorkerConnectResponse",
    "WorkerDisconnectResponse",
    "WorkerGetSceneInfoResponse",
    "WorkerVerifySceneResponse",
    "WorkerGetWorkScopeResponse",
    "WorkerPublishArtifactsResponse",
    nullptr
  };
  return names;
}

inline const char *EnumNameWorkerResponseData(WorkerResponseData e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesWorkerResponseData()[index];
}

template<typename T> struct WorkerResponseDataTraits {
  static const WorkerResponseData enum_value = WorkerResponseData_NONE;
};

template<> struct WorkerResponseDataTraits<WorkerErrorResponse> {
  static const WorkerResponseData enum_value = WorkerResponseData_WorkerErrorResponse;
};

template<> struct WorkerResponseDataTraits<WorkerConnectResponse> {
  static const WorkerResponseData enum_value = WorkerResponseData_WorkerConnectResponse;
};

template<> struct WorkerResponseDataTraits<WorkerDisconnectResponse> {
  static const WorkerResponseData enum_value = WorkerResponseData_WorkerDisconnectResponse;
};

template<> struct WorkerResponseDataTraits<WorkerGetSceneInfoResponse> {
  static const WorkerResponseData enum_value = WorkerResponseData_WorkerGetSceneInfoResponse;
};

template<> struct WorkerResponseDataTraits<WorkerVerifySceneResponse> {
  static const WorkerResponseData enum_value = WorkerResponseData_WorkerVerifySceneResponse;
};

template<> struct WorkerResponseDataTraits<WorkerGetWorkScopeResponse> {
  static const WorkerResponseData enum_value = WorkerResponseData_WorkerGetWorkScopeResponse;
};

template<> struct WorkerResponseDataTraits<WorkerPublishArtifactsResponse> {
  static const WorkerResponseData enum_value = WorkerResponseData_WorkerPublishArtifactsResponse;
};

bool VerifyWorkerResponseData(flatbuffers::Verifier &verifier, const void *obj, WorkerResponseData type);
bool VerifyWorkerResponseDataVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

enum CommanderRequestData {
  CommanderRequestData_NONE = 0,
  CommanderRequestData_CommanderGetSurfaceInfoRequest = 1,
  CommanderRequestData_CommanderGetSurfaceRequest = 2,
  CommanderRequestData_MIN = CommanderRequestData_NONE,
  CommanderRequestData_MAX = CommanderRequestData_CommanderGetSurfaceRequest
};

inline CommanderRequestData (&EnumValuesCommanderRequestData())[3] {
  static CommanderRequestData values[] = {
    CommanderRequestData_NONE,
    CommanderRequestData_CommanderGetSurfaceInfoRequest,
    CommanderRequestData_CommanderGetSurfaceRequest
  };
  return values;
}

inline const char **EnumNamesCommanderRequestData() {
  static const char *names[] = {
    "NONE",
    "CommanderGetSurfaceInfoRequest",
    "CommanderGetSurfaceRequest",
    nullptr
  };
  return names;
}

inline const char *EnumNameCommanderRequestData(CommanderRequestData e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesCommanderRequestData()[index];
}

template<typename T> struct CommanderRequestDataTraits {
  static const CommanderRequestData enum_value = CommanderRequestData_NONE;
};

template<> struct CommanderRequestDataTraits<CommanderGetSurfaceInfoRequest> {
  static const CommanderRequestData enum_value = CommanderRequestData_CommanderGetSurfaceInfoRequest;
};

template<> struct CommanderRequestDataTraits<CommanderGetSurfaceRequest> {
  static const CommanderRequestData enum_value = CommanderRequestData_CommanderGetSurfaceRequest;
};

bool VerifyCommanderRequestData(flatbuffers::Verifier &verifier, const void *obj, CommanderRequestData type);
bool VerifyCommanderRequestDataVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

enum SurfaceImageFormat {
  SurfaceImageFormat_Png = 0,
  SurfaceImageFormat_Unknown = 1,
  SurfaceImageFormat_MIN = SurfaceImageFormat_Png,
  SurfaceImageFormat_MAX = SurfaceImageFormat_Unknown
};

inline SurfaceImageFormat (&EnumValuesSurfaceImageFormat())[2] {
  static SurfaceImageFormat values[] = {
    SurfaceImageFormat_Png,
    SurfaceImageFormat_Unknown
  };
  return values;
}

inline const char **EnumNamesSurfaceImageFormat() {
  static const char *names[] = {
    "Png",
    "Unknown",
    nullptr
  };
  return names;
}

inline const char *EnumNameSurfaceImageFormat(SurfaceImageFormat e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesSurfaceImageFormat()[index];
}

enum CommanderResponseData {
  CommanderResponseData_NONE = 0,
  CommanderResponseData_CommanderGetSurfaceInfoResponse = 1,
  CommanderResponseData_CommanderGetSurfaceResponse = 2,
  CommanderResponseData_MIN = CommanderResponseData_NONE,
  CommanderResponseData_MAX = CommanderResponseData_CommanderGetSurfaceResponse
};

inline CommanderResponseData (&EnumValuesCommanderResponseData())[3] {
  static CommanderResponseData values[] = {
    CommanderResponseData_NONE,
    CommanderResponseData_CommanderGetSurfaceInfoResponse,
    CommanderResponseData_CommanderGetSurfaceResponse
  };
  return values;
}

inline const char **EnumNamesCommanderResponseData() {
  static const char *names[] = {
    "NONE",
    "CommanderGetSurfaceInfoResponse",
    "CommanderGetSurfaceResponse",
    nullptr
  };
  return names;
}

inline const char *EnumNameCommanderResponseData(CommanderResponseData e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesCommanderResponseData()[index];
}

template<typename T> struct CommanderResponseDataTraits {
  static const CommanderResponseData enum_value = CommanderResponseData_NONE;
};

template<> struct CommanderResponseDataTraits<CommanderGetSurfaceInfoResponse> {
  static const CommanderResponseData enum_value = CommanderResponseData_CommanderGetSurfaceInfoResponse;
};

template<> struct CommanderResponseDataTraits<CommanderGetSurfaceResponse> {
  static const CommanderResponseData enum_value = CommanderResponseData_CommanderGetSurfaceResponse;
};

bool VerifyCommanderResponseData(flatbuffers::Verifier &verifier, const void *obj, CommanderResponseData type);
bool VerifyCommanderResponseDataVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

enum ParcelData {
  ParcelData_NONE = 0,
  ParcelData_WorkerRequest = 1,
  ParcelData_WorkerResponse = 2,
  ParcelData_CommanderRequest = 3,
  ParcelData_CommanderResponse = 4,
  ParcelData_MIN = ParcelData_NONE,
  ParcelData_MAX = ParcelData_CommanderResponse
};

inline ParcelData (&EnumValuesParcelData())[5] {
  static ParcelData values[] = {
    ParcelData_NONE,
    ParcelData_WorkerRequest,
    ParcelData_WorkerResponse,
    ParcelData_CommanderRequest,
    ParcelData_CommanderResponse
  };
  return values;
}

inline const char **EnumNamesParcelData() {
  static const char *names[] = {
    "NONE",
    "WorkerRequest",
    "WorkerResponse",
    "CommanderRequest",
    "CommanderResponse",
    nullptr
  };
  return names;
}

inline const char *EnumNameParcelData(ParcelData e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesParcelData()[index];
}

template<typename T> struct ParcelDataTraits {
  static const ParcelData enum_value = ParcelData_NONE;
};

template<> struct ParcelDataTraits<WorkerRequest> {
  static const ParcelData enum_value = ParcelData_WorkerRequest;
};

template<> struct ParcelDataTraits<WorkerResponse> {
  static const ParcelData enum_value = ParcelData_WorkerResponse;
};

template<> struct ParcelDataTraits<CommanderRequest> {
  static const ParcelData enum_value = ParcelData_CommanderRequest;
};

template<> struct ParcelDataTraits<CommanderResponse> {
  static const ParcelData enum_value = ParcelData_CommanderResponse;
};

bool VerifyParcelData(flatbuffers::Verifier &verifier, const void *obj, ParcelData type);
bool VerifyParcelDataVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

struct Vec3 FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_X = 4,
    VT_Y = 6,
    VT_Z = 8
  };
  float x() const {
    return GetField<float>(VT_X, 0.0f);
  }
  float y() const {
    return GetField<float>(VT_Y, 0.0f);
  }
  float z() const {
    return GetField<float>(VT_Z, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_X) &&
           VerifyField<float>(verifier, VT_Y) &&
           VerifyField<float>(verifier, VT_Z) &&
           verifier.EndTable();
  }
};

struct Vec3Builder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_x(float x) {
    fbb_.AddElement<float>(Vec3::VT_X, x, 0.0f);
  }
  void add_y(float y) {
    fbb_.AddElement<float>(Vec3::VT_Y, y, 0.0f);
  }
  void add_z(float z) {
    fbb_.AddElement<float>(Vec3::VT_Z, z, 0.0f);
  }
  explicit Vec3Builder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  Vec3Builder &operator=(const Vec3Builder &);
  flatbuffers::Offset<Vec3> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Vec3>(end);
    return o;
  }
};

inline flatbuffers::Offset<Vec3> CreateVec3(
    flatbuffers::FlatBufferBuilder &_fbb,
    float x = 0.0f,
    float y = 0.0f,
    float z = 0.0f) {
  Vec3Builder builder_(_fbb);
  builder_.add_z(z);
  builder_.add_y(y);
  builder_.add_x(x);
  return builder_.Finish();
}

struct Pixel FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_COLOR = 4,
    VT_VARIANCE = 6,
    VT_SAMPLES = 8
  };
  const Vec3 *color() const {
    return GetPointer<const Vec3 *>(VT_COLOR);
  }
  const Vec3 *variance() const {
    return GetPointer<const Vec3 *>(VT_VARIANCE);
  }
  uint64_t samples() const {
    return GetField<uint64_t>(VT_SAMPLES, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_COLOR) &&
           verifier.VerifyTable(color()) &&
           VerifyOffset(verifier, VT_VARIANCE) &&
           verifier.VerifyTable(variance()) &&
           VerifyField<uint64_t>(verifier, VT_SAMPLES) &&
           verifier.EndTable();
  }
};

struct PixelBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_color(flatbuffers::Offset<Vec3> color) {
    fbb_.AddOffset(Pixel::VT_COLOR, color);
  }
  void add_variance(flatbuffers::Offset<Vec3> variance) {
    fbb_.AddOffset(Pixel::VT_VARIANCE, variance);
  }
  void add_samples(uint64_t samples) {
    fbb_.AddElement<uint64_t>(Pixel::VT_SAMPLES, samples, 0);
  }
  explicit PixelBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PixelBuilder &operator=(const PixelBuilder &);
  flatbuffers::Offset<Pixel> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Pixel>(end);
    return o;
  }
};

inline flatbuffers::Offset<Pixel> CreatePixel(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<Vec3> color = 0,
    flatbuffers::Offset<Vec3> variance = 0,
    uint64_t samples = 0) {
  PixelBuilder builder_(_fbb);
  builder_.add_samples(samples);
  builder_.add_variance(variance);
  builder_.add_color(color);
  return builder_.Finish();
}

struct ChunkInfo FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_X = 4,
    VT_Y = 6,
    VT_W = 8,
    VT_H = 10
  };
  uint16_t x() const {
    return GetField<uint16_t>(VT_X, 0);
  }
  uint16_t y() const {
    return GetField<uint16_t>(VT_Y, 0);
  }
  uint16_t w() const {
    return GetField<uint16_t>(VT_W, 0);
  }
  uint16_t h() const {
    return GetField<uint16_t>(VT_H, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_X) &&
           VerifyField<uint16_t>(verifier, VT_Y) &&
           VerifyField<uint16_t>(verifier, VT_W) &&
           VerifyField<uint16_t>(verifier, VT_H) &&
           verifier.EndTable();
  }
};

struct ChunkInfoBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_x(uint16_t x) {
    fbb_.AddElement<uint16_t>(ChunkInfo::VT_X, x, 0);
  }
  void add_y(uint16_t y) {
    fbb_.AddElement<uint16_t>(ChunkInfo::VT_Y, y, 0);
  }
  void add_w(uint16_t w) {
    fbb_.AddElement<uint16_t>(ChunkInfo::VT_W, w, 0);
  }
  void add_h(uint16_t h) {
    fbb_.AddElement<uint16_t>(ChunkInfo::VT_H, h, 0);
  }
  explicit ChunkInfoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ChunkInfoBuilder &operator=(const ChunkInfoBuilder &);
  flatbuffers::Offset<ChunkInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ChunkInfo>(end);
    return o;
  }
};

inline flatbuffers::Offset<ChunkInfo> CreateChunkInfo(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t x = 0,
    uint16_t y = 0,
    uint16_t w = 0,
    uint16_t h = 0) {
  ChunkInfoBuilder builder_(_fbb);
  builder_.add_h(h);
  builder_.add_w(w);
  builder_.add_y(y);
  builder_.add_x(x);
  return builder_.Finish();
}

struct Chunk FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_INFO = 4,
    VT_PIXELS = 6
  };
  const ChunkInfo *info() const {
    return GetPointer<const ChunkInfo *>(VT_INFO);
  }
  const flatbuffers::Vector<flatbuffers::Offset<Pixel>> *pixels() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Pixel>> *>(VT_PIXELS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_INFO) &&
           verifier.VerifyTable(info()) &&
           VerifyOffset(verifier, VT_PIXELS) &&
           verifier.Verify(pixels()) &&
           verifier.VerifyVectorOfTables(pixels()) &&
           verifier.EndTable();
  }
};

struct ChunkBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_info(flatbuffers::Offset<ChunkInfo> info) {
    fbb_.AddOffset(Chunk::VT_INFO, info);
  }
  void add_pixels(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Pixel>>> pixels) {
    fbb_.AddOffset(Chunk::VT_PIXELS, pixels);
  }
  explicit ChunkBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ChunkBuilder &operator=(const ChunkBuilder &);
  flatbuffers::Offset<Chunk> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Chunk>(end);
    return o;
  }
};

inline flatbuffers::Offset<Chunk> CreateChunk(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<ChunkInfo> info = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Pixel>>> pixels = 0) {
  ChunkBuilder builder_(_fbb);
  builder_.add_pixels(pixels);
  builder_.add_info(info);
  return builder_.Finish();
}

inline flatbuffers::Offset<Chunk> CreateChunkDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<ChunkInfo> info = 0,
    const std::vector<flatbuffers::Offset<Pixel>> *pixels = nullptr) {
  return Dcdr::Interconnect::DcdrFlatBuffers::CreateChunk(
      _fbb,
      info,
      pixels ? _fbb.CreateVector<flatbuffers::Offset<Pixel>>(*pixels) : 0);
}

struct ChunkTask FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_CHUNK = 4,
    VT_ITERATIONS = 6
  };
  const ChunkInfo *chunk() const {
    return GetPointer<const ChunkInfo *>(VT_CHUNK);
  }
  uint32_t iterations() const {
    return GetField<uint32_t>(VT_ITERATIONS, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_CHUNK) &&
           verifier.VerifyTable(chunk()) &&
           VerifyField<uint32_t>(verifier, VT_ITERATIONS) &&
           verifier.EndTable();
  }
};

struct ChunkTaskBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_chunk(flatbuffers::Offset<ChunkInfo> chunk) {
    fbb_.AddOffset(ChunkTask::VT_CHUNK, chunk);
  }
  void add_iterations(uint32_t iterations) {
    fbb_.AddElement<uint32_t>(ChunkTask::VT_ITERATIONS, iterations, 0);
  }
  explicit ChunkTaskBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ChunkTaskBuilder &operator=(const ChunkTaskBuilder &);
  flatbuffers::Offset<ChunkTask> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ChunkTask>(end);
    return o;
  }
};

inline flatbuffers::Offset<ChunkTask> CreateChunkTask(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<ChunkInfo> chunk = 0,
    uint32_t iterations = 0) {
  ChunkTaskBuilder builder_(_fbb);
  builder_.add_iterations(iterations);
  builder_.add_chunk(chunk);
  return builder_.Finish();
}

struct WorkerConnectRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_TOKEN = 4
  };
  const flatbuffers::Vector<uint8_t> *token() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_TOKEN);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_TOKEN) &&
           verifier.Verify(token()) &&
           verifier.EndTable();
  }
};

struct WorkerConnectRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_token(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> token) {
    fbb_.AddOffset(WorkerConnectRequest::VT_TOKEN, token);
  }
  explicit WorkerConnectRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  WorkerConnectRequestBuilder &operator=(const WorkerConnectRequestBuilder &);
  flatbuffers::Offset<WorkerConnectRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<WorkerConnectRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<WorkerConnectRequest> CreateWorkerConnectRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> token = 0) {
  WorkerConnectRequestBuilder builder_(_fbb);
  builder_.add_token(token);
  return builder_.Finish();
}

inline flatbuffers::Offset<WorkerConnectRequest> CreateWorkerConnectRequestDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint8_t> *token = nullptr) {
  return Dcdr::Interconnect::DcdrFlatBuffers::CreateWorkerConnectRequest(
      _fbb,
      token ? _fbb.CreateVector<uint8_t>(*token) : 0);
}

struct WorkerDisconnectRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct WorkerDisconnectRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit WorkerDisconnectRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  WorkerDisconnectRequestBuilder &operator=(const WorkerDisconnectRequestBuilder &);
  flatbuffers::Offset<WorkerDisconnectRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<WorkerDisconnectRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<WorkerDisconnectRequest> CreateWorkerDisconnectRequest(
    flatbuffers::FlatBufferBuilder &_fbb) {
  WorkerDisconnectRequestBuilder builder_(_fbb);
  return builder_.Finish();
}

struct WorkerGetSceneInfoRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct WorkerGetSceneInfoRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit WorkerGetSceneInfoRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  WorkerGetSceneInfoRequestBuilder &operator=(const WorkerGetSceneInfoRequestBuilder &);
  flatbuffers::Offset<WorkerGetSceneInfoRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<WorkerGetSceneInfoRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<WorkerGetSceneInfoRequest> CreateWorkerGetSceneInfoRequest(
    flatbuffers::FlatBufferBuilder &_fbb) {
  WorkerGetSceneInfoRequestBuilder builder_(_fbb);
  return builder_.Finish();
}

struct WorkerVerifySceneRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_SCENEMD5 = 4
  };
  const flatbuffers::String *sceneMD5() const {
    return GetPointer<const flatbuffers::String *>(VT_SCENEMD5);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_SCENEMD5) &&
           verifier.Verify(sceneMD5()) &&
           verifier.EndTable();
  }
};

struct WorkerVerifySceneRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_sceneMD5(flatbuffers::Offset<flatbuffers::String> sceneMD5) {
    fbb_.AddOffset(WorkerVerifySceneRequest::VT_SCENEMD5, sceneMD5);
  }
  explicit WorkerVerifySceneRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  WorkerVerifySceneRequestBuilder &operator=(const WorkerVerifySceneRequestBuilder &);
  flatbuffers::Offset<WorkerVerifySceneRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<WorkerVerifySceneRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<WorkerVerifySceneRequest> CreateWorkerVerifySceneRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> sceneMD5 = 0) {
  WorkerVerifySceneRequestBuilder builder_(_fbb);
  builder_.add_sceneMD5(sceneMD5);
  return builder_.Finish();
}

inline flatbuffers::Offset<WorkerVerifySceneRequest> CreateWorkerVerifySceneRequestDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *sceneMD5 = nullptr) {
  return Dcdr::Interconnect::DcdrFlatBuffers::CreateWorkerVerifySceneRequest(
      _fbb,
      sceneMD5 ? _fbb.CreateString(sceneMD5) : 0);
}

struct WorkerGetWorkScopeRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_THREADSAVAILABLE = 4
  };
  uint16_t threadsAvailable() const {
    return GetField<uint16_t>(VT_THREADSAVAILABLE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_THREADSAVAILABLE) &&
           verifier.EndTable();
  }
};

struct WorkerGetWorkScopeRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_threadsAvailable(uint16_t threadsAvailable) {
    fbb_.AddElement<uint16_t>(WorkerGetWorkScopeRequest::VT_THREADSAVAILABLE, threadsAvailable, 0);
  }
  explicit WorkerGetWorkScopeRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  WorkerGetWorkScopeRequestBuilder &operator=(const WorkerGetWorkScopeRequestBuilder &);
  flatbuffers::Offset<WorkerGetWorkScopeRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<WorkerGetWorkScopeRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<WorkerGetWorkScopeRequest> CreateWorkerGetWorkScopeRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t threadsAvailable = 0) {
  WorkerGetWorkScopeRequestBuilder builder_(_fbb);
  builder_.add_threadsAvailable(threadsAvailable);
  return builder_.Finish();
}

struct WorkerPublishArtifactsRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_CHUNKS = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<Chunk>> *chunks() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Chunk>> *>(VT_CHUNKS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_CHUNKS) &&
           verifier.Verify(chunks()) &&
           verifier.VerifyVectorOfTables(chunks()) &&
           verifier.EndTable();
  }
};

struct WorkerPublishArtifactsRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_chunks(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Chunk>>> chunks) {
    fbb_.AddOffset(WorkerPublishArtifactsRequest::VT_CHUNKS, chunks);
  }
  explicit WorkerPublishArtifactsRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  WorkerPublishArtifactsRequestBuilder &operator=(const WorkerPublishArtifactsRequestBuilder &);
  flatbuffers::Offset<WorkerPublishArtifactsRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<WorkerPublishArtifactsRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<WorkerPublishArtifactsRequest> CreateWorkerPublishArtifactsRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Chunk>>> chunks = 0) {
  WorkerPublishArtifactsRequestBuilder builder_(_fbb);
  builder_.add_chunks(chunks);
  return builder_.Finish();
}

inline flatbuffers::Offset<WorkerPublishArtifactsRequest> CreateWorkerPublishArtifactsRequestDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<Chunk>> *chunks = nullptr) {
  return Dcdr::Interconnect::DcdrFlatBuffers::CreateWorkerPublishArtifactsRequest(
      _fbb,
      chunks ? _fbb.CreateVector<flatbuffers::Offset<Chunk>>(*chunks) : 0);
}

struct WorkerRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_SESSION = 4,
    VT_REQUESTDATA_TYPE = 6,
    VT_REQUESTDATA = 8
  };
  const flatbuffers::Vector<uint8_t> *session() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_SESSION);
  }
  WorkerRequestData requestData_type() const {
    return static_cast<WorkerRequestData>(GetField<uint8_t>(VT_REQUESTDATA_TYPE, 0));
  }
  const void *requestData() const {
    return GetPointer<const void *>(VT_REQUESTDATA);
  }
  template<typename T> const T *requestData_as() const;
  const WorkerConnectRequest *requestData_as_WorkerConnectRequest() const {
    return requestData_type() == WorkerRequestData_WorkerConnectRequest ? static_cast<const WorkerConnectRequest *>(requestData()) : nullptr;
  }
  const WorkerDisconnectRequest *requestData_as_WorkerDisconnectRequest() const {
    return requestData_type() == WorkerRequestData_WorkerDisconnectRequest ? static_cast<const WorkerDisconnectRequest *>(requestData()) : nullptr;
  }
  const WorkerGetSceneInfoRequest *requestData_as_WorkerGetSceneInfoRequest() const {
    return requestData_type() == WorkerRequestData_WorkerGetSceneInfoRequest ? static_cast<const WorkerGetSceneInfoRequest *>(requestData()) : nullptr;
  }
  const WorkerVerifySceneRequest *requestData_as_WorkerVerifySceneRequest() const {
    return requestData_type() == WorkerRequestData_WorkerVerifySceneRequest ? static_cast<const WorkerVerifySceneRequest *>(requestData()) : nullptr;
  }
  const WorkerGetWorkScopeRequest *requestData_as_WorkerGetWorkScopeRequest() const {
    return requestData_type() == WorkerRequestData_WorkerGetWorkScopeRequest ? static_cast<const WorkerGetWorkScopeRequest *>(requestData()) : nullptr;
  }
  const WorkerPublishArtifactsRequest *requestData_as_WorkerPublishArtifactsRequest() const {
    return requestData_type() == WorkerRequestData_WorkerPublishArtifactsRequest ? static_cast<const WorkerPublishArtifactsRequest *>(requestData()) : nullptr;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_SESSION) &&
           verifier.Verify(session()) &&
           VerifyField<uint8_t>(verifier, VT_REQUESTDATA_TYPE) &&
           VerifyOffset(verifier, VT_REQUESTDATA) &&
           VerifyWorkerRequestData(verifier, requestData(), requestData_type()) &&
           verifier.EndTable();
  }
};

template<> inline const WorkerConnectRequest *WorkerRequest::requestData_as<WorkerConnectRequest>() const {
  return requestData_as_WorkerConnectRequest();
}

template<> inline const WorkerDisconnectRequest *WorkerRequest::requestData_as<WorkerDisconnectRequest>() const {
  return requestData_as_WorkerDisconnectRequest();
}

template<> inline const WorkerGetSceneInfoRequest *WorkerRequest::requestData_as<WorkerGetSceneInfoRequest>() const {
  return requestData_as_WorkerGetSceneInfoRequest();
}

template<> inline const WorkerVerifySceneRequest *WorkerRequest::requestData_as<WorkerVerifySceneRequest>() const {
  return requestData_as_WorkerVerifySceneRequest();
}

template<> inline const WorkerGetWorkScopeRequest *WorkerRequest::requestData_as<WorkerGetWorkScopeRequest>() const {
  return requestData_as_WorkerGetWorkScopeRequest();
}

template<> inline const WorkerPublishArtifactsRequest *WorkerRequest::requestData_as<WorkerPublishArtifactsRequest>() const {
  return requestData_as_WorkerPublishArtifactsRequest();
}

struct WorkerRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_session(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> session) {
    fbb_.AddOffset(WorkerRequest::VT_SESSION, session);
  }
  void add_requestData_type(WorkerRequestData requestData_type) {
    fbb_.AddElement<uint8_t>(WorkerRequest::VT_REQUESTDATA_TYPE, static_cast<uint8_t>(requestData_type), 0);
  }
  void add_requestData(flatbuffers::Offset<void> requestData) {
    fbb_.AddOffset(WorkerRequest::VT_REQUESTDATA, requestData);
  }
  explicit WorkerRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  WorkerRequestBuilder &operator=(const WorkerRequestBuilder &);
  flatbuffers::Offset<WorkerRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<WorkerRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<WorkerRequest> CreateWorkerRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> session = 0,
    WorkerRequestData requestData_type = WorkerRequestData_NONE,
    flatbuffers::Offset<void> requestData = 0) {
  WorkerRequestBuilder builder_(_fbb);
  builder_.add_requestData(requestData);
  builder_.add_session(session);
  builder_.add_requestData_type(requestData_type);
  return builder_.Finish();
}

inline flatbuffers::Offset<WorkerRequest> CreateWorkerRequestDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint8_t> *session = nullptr,
    WorkerRequestData requestData_type = WorkerRequestData_NONE,
    flatbuffers::Offset<void> requestData = 0) {
  return Dcdr::Interconnect::DcdrFlatBuffers::CreateWorkerRequest(
      _fbb,
      session ? _fbb.CreateVector<uint8_t>(*session) : 0,
      requestData_type,
      requestData);
}

struct WorkerErrorResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_CAUSE = 4
  };
  const flatbuffers::String *cause() const {
    return GetPointer<const flatbuffers::String *>(VT_CAUSE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_CAUSE) &&
           verifier.Verify(cause()) &&
           verifier.EndTable();
  }
};

struct WorkerErrorResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_cause(flatbuffers::Offset<flatbuffers::String> cause) {
    fbb_.AddOffset(WorkerErrorResponse::VT_CAUSE, cause);
  }
  explicit WorkerErrorResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  WorkerErrorResponseBuilder &operator=(const WorkerErrorResponseBuilder &);
  flatbuffers::Offset<WorkerErrorResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<WorkerErrorResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<WorkerErrorResponse> CreateWorkerErrorResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> cause = 0) {
  WorkerErrorResponseBuilder builder_(_fbb);
  builder_.add_cause(cause);
  return builder_.Finish();
}

inline flatbuffers::Offset<WorkerErrorResponse> CreateWorkerErrorResponseDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *cause = nullptr) {
  return Dcdr::Interconnect::DcdrFlatBuffers::CreateWorkerErrorResponse(
      _fbb,
      cause ? _fbb.CreateString(cause) : 0);
}

struct WorkerConnectResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_CONNECTIONID = 4
  };
  const flatbuffers::Vector<uint8_t> *connectionId() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_CONNECTIONID);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_CONNECTIONID) &&
           verifier.Verify(connectionId()) &&
           verifier.EndTable();
  }
};

struct WorkerConnectResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_connectionId(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> connectionId) {
    fbb_.AddOffset(WorkerConnectResponse::VT_CONNECTIONID, connectionId);
  }
  explicit WorkerConnectResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  WorkerConnectResponseBuilder &operator=(const WorkerConnectResponseBuilder &);
  flatbuffers::Offset<WorkerConnectResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<WorkerConnectResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<WorkerConnectResponse> CreateWorkerConnectResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> connectionId = 0) {
  WorkerConnectResponseBuilder builder_(_fbb);
  builder_.add_connectionId(connectionId);
  return builder_.Finish();
}

inline flatbuffers::Offset<WorkerConnectResponse> CreateWorkerConnectResponseDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint8_t> *connectionId = nullptr) {
  return Dcdr::Interconnect::DcdrFlatBuffers::CreateWorkerConnectResponse(
      _fbb,
      connectionId ? _fbb.CreateVector<uint8_t>(*connectionId) : 0);
}

struct WorkerDisconnectResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct WorkerDisconnectResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit WorkerDisconnectResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  WorkerDisconnectResponseBuilder &operator=(const WorkerDisconnectResponseBuilder &);
  flatbuffers::Offset<WorkerDisconnectResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<WorkerDisconnectResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<WorkerDisconnectResponse> CreateWorkerDisconnectResponse(
    flatbuffers::FlatBufferBuilder &_fbb) {
  WorkerDisconnectResponseBuilder builder_(_fbb);
  return builder_.Finish();
}

struct WorkerGetSceneInfoResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_SCENEID = 4
  };
  const flatbuffers::String *sceneId() const {
    return GetPointer<const flatbuffers::String *>(VT_SCENEID);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_SCENEID) &&
           verifier.Verify(sceneId()) &&
           verifier.EndTable();
  }
};

struct WorkerGetSceneInfoResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_sceneId(flatbuffers::Offset<flatbuffers::String> sceneId) {
    fbb_.AddOffset(WorkerGetSceneInfoResponse::VT_SCENEID, sceneId);
  }
  explicit WorkerGetSceneInfoResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  WorkerGetSceneInfoResponseBuilder &operator=(const WorkerGetSceneInfoResponseBuilder &);
  flatbuffers::Offset<WorkerGetSceneInfoResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<WorkerGetSceneInfoResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<WorkerGetSceneInfoResponse> CreateWorkerGetSceneInfoResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> sceneId = 0) {
  WorkerGetSceneInfoResponseBuilder builder_(_fbb);
  builder_.add_sceneId(sceneId);
  return builder_.Finish();
}

inline flatbuffers::Offset<WorkerGetSceneInfoResponse> CreateWorkerGetSceneInfoResponseDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *sceneId = nullptr) {
  return Dcdr::Interconnect::DcdrFlatBuffers::CreateWorkerGetSceneInfoResponse(
      _fbb,
      sceneId ? _fbb.CreateString(sceneId) : 0);
}

struct WorkerVerifySceneResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct WorkerVerifySceneResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit WorkerVerifySceneResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  WorkerVerifySceneResponseBuilder &operator=(const WorkerVerifySceneResponseBuilder &);
  flatbuffers::Offset<WorkerVerifySceneResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<WorkerVerifySceneResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<WorkerVerifySceneResponse> CreateWorkerVerifySceneResponse(
    flatbuffers::FlatBufferBuilder &_fbb) {
  WorkerVerifySceneResponseBuilder builder_(_fbb);
  return builder_.Finish();
}

struct WorkerGetWorkScopeResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_TASKS = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<ChunkTask>> *tasks() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<ChunkTask>> *>(VT_TASKS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_TASKS) &&
           verifier.Verify(tasks()) &&
           verifier.VerifyVectorOfTables(tasks()) &&
           verifier.EndTable();
  }
};

struct WorkerGetWorkScopeResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_tasks(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ChunkTask>>> tasks) {
    fbb_.AddOffset(WorkerGetWorkScopeResponse::VT_TASKS, tasks);
  }
  explicit WorkerGetWorkScopeResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  WorkerGetWorkScopeResponseBuilder &operator=(const WorkerGetWorkScopeResponseBuilder &);
  flatbuffers::Offset<WorkerGetWorkScopeResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<WorkerGetWorkScopeResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<WorkerGetWorkScopeResponse> CreateWorkerGetWorkScopeResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ChunkTask>>> tasks = 0) {
  WorkerGetWorkScopeResponseBuilder builder_(_fbb);
  builder_.add_tasks(tasks);
  return builder_.Finish();
}

inline flatbuffers::Offset<WorkerGetWorkScopeResponse> CreateWorkerGetWorkScopeResponseDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<ChunkTask>> *tasks = nullptr) {
  return Dcdr::Interconnect::DcdrFlatBuffers::CreateWorkerGetWorkScopeResponse(
      _fbb,
      tasks ? _fbb.CreateVector<flatbuffers::Offset<ChunkTask>>(*tasks) : 0);
}

struct WorkerPublishArtifactsResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct WorkerPublishArtifactsResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit WorkerPublishArtifactsResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  WorkerPublishArtifactsResponseBuilder &operator=(const WorkerPublishArtifactsResponseBuilder &);
  flatbuffers::Offset<WorkerPublishArtifactsResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<WorkerPublishArtifactsResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<WorkerPublishArtifactsResponse> CreateWorkerPublishArtifactsResponse(
    flatbuffers::FlatBufferBuilder &_fbb) {
  WorkerPublishArtifactsResponseBuilder builder_(_fbb);
  return builder_.Finish();
}

struct WorkerResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_SESSION = 4,
    VT_RESPONSEDATA_TYPE = 6,
    VT_RESPONSEDATA = 8
  };
  const flatbuffers::Vector<uint8_t> *session() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_SESSION);
  }
  WorkerResponseData responseData_type() const {
    return static_cast<WorkerResponseData>(GetField<uint8_t>(VT_RESPONSEDATA_TYPE, 0));
  }
  const void *responseData() const {
    return GetPointer<const void *>(VT_RESPONSEDATA);
  }
  template<typename T> const T *responseData_as() const;
  const WorkerErrorResponse *responseData_as_WorkerErrorResponse() const {
    return responseData_type() == WorkerResponseData_WorkerErrorResponse ? static_cast<const WorkerErrorResponse *>(responseData()) : nullptr;
  }
  const WorkerConnectResponse *responseData_as_WorkerConnectResponse() const {
    return responseData_type() == WorkerResponseData_WorkerConnectResponse ? static_cast<const WorkerConnectResponse *>(responseData()) : nullptr;
  }
  const WorkerDisconnectResponse *responseData_as_WorkerDisconnectResponse() const {
    return responseData_type() == WorkerResponseData_WorkerDisconnectResponse ? static_cast<const WorkerDisconnectResponse *>(responseData()) : nullptr;
  }
  const WorkerGetSceneInfoResponse *responseData_as_WorkerGetSceneInfoResponse() const {
    return responseData_type() == WorkerResponseData_WorkerGetSceneInfoResponse ? static_cast<const WorkerGetSceneInfoResponse *>(responseData()) : nullptr;
  }
  const WorkerVerifySceneResponse *responseData_as_WorkerVerifySceneResponse() const {
    return responseData_type() == WorkerResponseData_WorkerVerifySceneResponse ? static_cast<const WorkerVerifySceneResponse *>(responseData()) : nullptr;
  }
  const WorkerGetWorkScopeResponse *responseData_as_WorkerGetWorkScopeResponse() const {
    return responseData_type() == WorkerResponseData_WorkerGetWorkScopeResponse ? static_cast<const WorkerGetWorkScopeResponse *>(responseData()) : nullptr;
  }
  const WorkerPublishArtifactsResponse *responseData_as_WorkerPublishArtifactsResponse() const {
    return responseData_type() == WorkerResponseData_WorkerPublishArtifactsResponse ? static_cast<const WorkerPublishArtifactsResponse *>(responseData()) : nullptr;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_SESSION) &&
           verifier.Verify(session()) &&
           VerifyField<uint8_t>(verifier, VT_RESPONSEDATA_TYPE) &&
           VerifyOffset(verifier, VT_RESPONSEDATA) &&
           VerifyWorkerResponseData(verifier, responseData(), responseData_type()) &&
           verifier.EndTable();
  }
};

template<> inline const WorkerErrorResponse *WorkerResponse::responseData_as<WorkerErrorResponse>() const {
  return responseData_as_WorkerErrorResponse();
}

template<> inline const WorkerConnectResponse *WorkerResponse::responseData_as<WorkerConnectResponse>() const {
  return responseData_as_WorkerConnectResponse();
}

template<> inline const WorkerDisconnectResponse *WorkerResponse::responseData_as<WorkerDisconnectResponse>() const {
  return responseData_as_WorkerDisconnectResponse();
}

template<> inline const WorkerGetSceneInfoResponse *WorkerResponse::responseData_as<WorkerGetSceneInfoResponse>() const {
  return responseData_as_WorkerGetSceneInfoResponse();
}

template<> inline const WorkerVerifySceneResponse *WorkerResponse::responseData_as<WorkerVerifySceneResponse>() const {
  return responseData_as_WorkerVerifySceneResponse();
}

template<> inline const WorkerGetWorkScopeResponse *WorkerResponse::responseData_as<WorkerGetWorkScopeResponse>() const {
  return responseData_as_WorkerGetWorkScopeResponse();
}

template<> inline const WorkerPublishArtifactsResponse *WorkerResponse::responseData_as<WorkerPublishArtifactsResponse>() const {
  return responseData_as_WorkerPublishArtifactsResponse();
}

struct WorkerResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_session(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> session) {
    fbb_.AddOffset(WorkerResponse::VT_SESSION, session);
  }
  void add_responseData_type(WorkerResponseData responseData_type) {
    fbb_.AddElement<uint8_t>(WorkerResponse::VT_RESPONSEDATA_TYPE, static_cast<uint8_t>(responseData_type), 0);
  }
  void add_responseData(flatbuffers::Offset<void> responseData) {
    fbb_.AddOffset(WorkerResponse::VT_RESPONSEDATA, responseData);
  }
  explicit WorkerResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  WorkerResponseBuilder &operator=(const WorkerResponseBuilder &);
  flatbuffers::Offset<WorkerResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<WorkerResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<WorkerResponse> CreateWorkerResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> session = 0,
    WorkerResponseData responseData_type = WorkerResponseData_NONE,
    flatbuffers::Offset<void> responseData = 0) {
  WorkerResponseBuilder builder_(_fbb);
  builder_.add_responseData(responseData);
  builder_.add_session(session);
  builder_.add_responseData_type(responseData_type);
  return builder_.Finish();
}

inline flatbuffers::Offset<WorkerResponse> CreateWorkerResponseDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint8_t> *session = nullptr,
    WorkerResponseData responseData_type = WorkerResponseData_NONE,
    flatbuffers::Offset<void> responseData = 0) {
  return Dcdr::Interconnect::DcdrFlatBuffers::CreateWorkerResponse(
      _fbb,
      session ? _fbb.CreateVector<uint8_t>(*session) : 0,
      responseData_type,
      responseData);
}

struct CommanderGetSurfaceInfoRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct CommanderGetSurfaceInfoRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit CommanderGetSurfaceInfoRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CommanderGetSurfaceInfoRequestBuilder &operator=(const CommanderGetSurfaceInfoRequestBuilder &);
  flatbuffers::Offset<CommanderGetSurfaceInfoRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CommanderGetSurfaceInfoRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<CommanderGetSurfaceInfoRequest> CreateCommanderGetSurfaceInfoRequest(
    flatbuffers::FlatBufferBuilder &_fbb) {
  CommanderGetSurfaceInfoRequestBuilder builder_(_fbb);
  return builder_.Finish();
}

struct CommanderGetSurfaceRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct CommanderGetSurfaceRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit CommanderGetSurfaceRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CommanderGetSurfaceRequestBuilder &operator=(const CommanderGetSurfaceRequestBuilder &);
  flatbuffers::Offset<CommanderGetSurfaceRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CommanderGetSurfaceRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<CommanderGetSurfaceRequest> CreateCommanderGetSurfaceRequest(
    flatbuffers::FlatBufferBuilder &_fbb) {
  CommanderGetSurfaceRequestBuilder builder_(_fbb);
  return builder_.Finish();
}

struct CommanderRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_REQUESTDATA_TYPE = 4,
    VT_REQUESTDATA = 6
  };
  CommanderRequestData requestData_type() const {
    return static_cast<CommanderRequestData>(GetField<uint8_t>(VT_REQUESTDATA_TYPE, 0));
  }
  const void *requestData() const {
    return GetPointer<const void *>(VT_REQUESTDATA);
  }
  template<typename T> const T *requestData_as() const;
  const CommanderGetSurfaceInfoRequest *requestData_as_CommanderGetSurfaceInfoRequest() const {
    return requestData_type() == CommanderRequestData_CommanderGetSurfaceInfoRequest ? static_cast<const CommanderGetSurfaceInfoRequest *>(requestData()) : nullptr;
  }
  const CommanderGetSurfaceRequest *requestData_as_CommanderGetSurfaceRequest() const {
    return requestData_type() == CommanderRequestData_CommanderGetSurfaceRequest ? static_cast<const CommanderGetSurfaceRequest *>(requestData()) : nullptr;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_REQUESTDATA_TYPE) &&
           VerifyOffset(verifier, VT_REQUESTDATA) &&
           VerifyCommanderRequestData(verifier, requestData(), requestData_type()) &&
           verifier.EndTable();
  }
};

template<> inline const CommanderGetSurfaceInfoRequest *CommanderRequest::requestData_as<CommanderGetSurfaceInfoRequest>() const {
  return requestData_as_CommanderGetSurfaceInfoRequest();
}

template<> inline const CommanderGetSurfaceRequest *CommanderRequest::requestData_as<CommanderGetSurfaceRequest>() const {
  return requestData_as_CommanderGetSurfaceRequest();
}

struct CommanderRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_requestData_type(CommanderRequestData requestData_type) {
    fbb_.AddElement<uint8_t>(CommanderRequest::VT_REQUESTDATA_TYPE, static_cast<uint8_t>(requestData_type), 0);
  }
  void add_requestData(flatbuffers::Offset<void> requestData) {
    fbb_.AddOffset(CommanderRequest::VT_REQUESTDATA, requestData);
  }
  explicit CommanderRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CommanderRequestBuilder &operator=(const CommanderRequestBuilder &);
  flatbuffers::Offset<CommanderRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CommanderRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<CommanderRequest> CreateCommanderRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    CommanderRequestData requestData_type = CommanderRequestData_NONE,
    flatbuffers::Offset<void> requestData = 0) {
  CommanderRequestBuilder builder_(_fbb);
  builder_.add_requestData(requestData);
  builder_.add_requestData_type(requestData_type);
  return builder_.Finish();
}

struct CommanderGetSurfaceInfoResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_WIDTH = 4,
    VT_HEIGHT = 6
  };
  uint32_t width() const {
    return GetField<uint32_t>(VT_WIDTH, 0);
  }
  uint32_t height() const {
    return GetField<uint32_t>(VT_HEIGHT, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_WIDTH) &&
           VerifyField<uint32_t>(verifier, VT_HEIGHT) &&
           verifier.EndTable();
  }
};

struct CommanderGetSurfaceInfoResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_width(uint32_t width) {
    fbb_.AddElement<uint32_t>(CommanderGetSurfaceInfoResponse::VT_WIDTH, width, 0);
  }
  void add_height(uint32_t height) {
    fbb_.AddElement<uint32_t>(CommanderGetSurfaceInfoResponse::VT_HEIGHT, height, 0);
  }
  explicit CommanderGetSurfaceInfoResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CommanderGetSurfaceInfoResponseBuilder &operator=(const CommanderGetSurfaceInfoResponseBuilder &);
  flatbuffers::Offset<CommanderGetSurfaceInfoResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CommanderGetSurfaceInfoResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<CommanderGetSurfaceInfoResponse> CreateCommanderGetSurfaceInfoResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t width = 0,
    uint32_t height = 0) {
  CommanderGetSurfaceInfoResponseBuilder builder_(_fbb);
  builder_.add_height(height);
  builder_.add_width(width);
  return builder_.Finish();
}

struct CommanderGetSurfaceResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_FORMAT = 4,
    VT_BUFFER = 6
  };
  SurfaceImageFormat format() const {
    return static_cast<SurfaceImageFormat>(GetField<uint16_t>(VT_FORMAT, 0));
  }
  const flatbuffers::Vector<uint8_t> *buffer() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_BUFFER);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_FORMAT) &&
           VerifyOffset(verifier, VT_BUFFER) &&
           verifier.Verify(buffer()) &&
           verifier.EndTable();
  }
};

struct CommanderGetSurfaceResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_format(SurfaceImageFormat format) {
    fbb_.AddElement<uint16_t>(CommanderGetSurfaceResponse::VT_FORMAT, static_cast<uint16_t>(format), 0);
  }
  void add_buffer(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> buffer) {
    fbb_.AddOffset(CommanderGetSurfaceResponse::VT_BUFFER, buffer);
  }
  explicit CommanderGetSurfaceResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CommanderGetSurfaceResponseBuilder &operator=(const CommanderGetSurfaceResponseBuilder &);
  flatbuffers::Offset<CommanderGetSurfaceResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CommanderGetSurfaceResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<CommanderGetSurfaceResponse> CreateCommanderGetSurfaceResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    SurfaceImageFormat format = SurfaceImageFormat_Png,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> buffer = 0) {
  CommanderGetSurfaceResponseBuilder builder_(_fbb);
  builder_.add_buffer(buffer);
  builder_.add_format(format);
  return builder_.Finish();
}

inline flatbuffers::Offset<CommanderGetSurfaceResponse> CreateCommanderGetSurfaceResponseDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    SurfaceImageFormat format = SurfaceImageFormat_Png,
    const std::vector<uint8_t> *buffer = nullptr) {
  return Dcdr::Interconnect::DcdrFlatBuffers::CreateCommanderGetSurfaceResponse(
      _fbb,
      format,
      buffer ? _fbb.CreateVector<uint8_t>(*buffer) : 0);
}

struct CommanderResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_RESPONSEDATA_TYPE = 4,
    VT_RESPONSEDATA = 6
  };
  CommanderResponseData responseData_type() const {
    return static_cast<CommanderResponseData>(GetField<uint8_t>(VT_RESPONSEDATA_TYPE, 0));
  }
  const void *responseData() const {
    return GetPointer<const void *>(VT_RESPONSEDATA);
  }
  template<typename T> const T *responseData_as() const;
  const CommanderGetSurfaceInfoResponse *responseData_as_CommanderGetSurfaceInfoResponse() const {
    return responseData_type() == CommanderResponseData_CommanderGetSurfaceInfoResponse ? static_cast<const CommanderGetSurfaceInfoResponse *>(responseData()) : nullptr;
  }
  const CommanderGetSurfaceResponse *responseData_as_CommanderGetSurfaceResponse() const {
    return responseData_type() == CommanderResponseData_CommanderGetSurfaceResponse ? static_cast<const CommanderGetSurfaceResponse *>(responseData()) : nullptr;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_RESPONSEDATA_TYPE) &&
           VerifyOffset(verifier, VT_RESPONSEDATA) &&
           VerifyCommanderResponseData(verifier, responseData(), responseData_type()) &&
           verifier.EndTable();
  }
};

template<> inline const CommanderGetSurfaceInfoResponse *CommanderResponse::responseData_as<CommanderGetSurfaceInfoResponse>() const {
  return responseData_as_CommanderGetSurfaceInfoResponse();
}

template<> inline const CommanderGetSurfaceResponse *CommanderResponse::responseData_as<CommanderGetSurfaceResponse>() const {
  return responseData_as_CommanderGetSurfaceResponse();
}

struct CommanderResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_responseData_type(CommanderResponseData responseData_type) {
    fbb_.AddElement<uint8_t>(CommanderResponse::VT_RESPONSEDATA_TYPE, static_cast<uint8_t>(responseData_type), 0);
  }
  void add_responseData(flatbuffers::Offset<void> responseData) {
    fbb_.AddOffset(CommanderResponse::VT_RESPONSEDATA, responseData);
  }
  explicit CommanderResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CommanderResponseBuilder &operator=(const CommanderResponseBuilder &);
  flatbuffers::Offset<CommanderResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CommanderResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<CommanderResponse> CreateCommanderResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    CommanderResponseData responseData_type = CommanderResponseData_NONE,
    flatbuffers::Offset<void> responseData = 0) {
  CommanderResponseBuilder builder_(_fbb);
  builder_.add_responseData(responseData);
  builder_.add_responseData_type(responseData_type);
  return builder_.Finish();
}

struct Parcel FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_PARCELDATA_TYPE = 4,
    VT_PARCELDATA = 6
  };
  ParcelData parcelData_type() const {
    return static_cast<ParcelData>(GetField<uint8_t>(VT_PARCELDATA_TYPE, 0));
  }
  const void *parcelData() const {
    return GetPointer<const void *>(VT_PARCELDATA);
  }
  template<typename T> const T *parcelData_as() const;
  const WorkerRequest *parcelData_as_WorkerRequest() const {
    return parcelData_type() == ParcelData_WorkerRequest ? static_cast<const WorkerRequest *>(parcelData()) : nullptr;
  }
  const WorkerResponse *parcelData_as_WorkerResponse() const {
    return parcelData_type() == ParcelData_WorkerResponse ? static_cast<const WorkerResponse *>(parcelData()) : nullptr;
  }
  const CommanderRequest *parcelData_as_CommanderRequest() const {
    return parcelData_type() == ParcelData_CommanderRequest ? static_cast<const CommanderRequest *>(parcelData()) : nullptr;
  }
  const CommanderResponse *parcelData_as_CommanderResponse() const {
    return parcelData_type() == ParcelData_CommanderResponse ? static_cast<const CommanderResponse *>(parcelData()) : nullptr;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_PARCELDATA_TYPE) &&
           VerifyOffset(verifier, VT_PARCELDATA) &&
           VerifyParcelData(verifier, parcelData(), parcelData_type()) &&
           verifier.EndTable();
  }
};

template<> inline const WorkerRequest *Parcel::parcelData_as<WorkerRequest>() const {
  return parcelData_as_WorkerRequest();
}

template<> inline const WorkerResponse *Parcel::parcelData_as<WorkerResponse>() const {
  return parcelData_as_WorkerResponse();
}

template<> inline const CommanderRequest *Parcel::parcelData_as<CommanderRequest>() const {
  return parcelData_as_CommanderRequest();
}

template<> inline const CommanderResponse *Parcel::parcelData_as<CommanderResponse>() const {
  return parcelData_as_CommanderResponse();
}

struct ParcelBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_parcelData_type(ParcelData parcelData_type) {
    fbb_.AddElement<uint8_t>(Parcel::VT_PARCELDATA_TYPE, static_cast<uint8_t>(parcelData_type), 0);
  }
  void add_parcelData(flatbuffers::Offset<void> parcelData) {
    fbb_.AddOffset(Parcel::VT_PARCELDATA, parcelData);
  }
  explicit ParcelBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ParcelBuilder &operator=(const ParcelBuilder &);
  flatbuffers::Offset<Parcel> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Parcel>(end);
    return o;
  }
};

inline flatbuffers::Offset<Parcel> CreateParcel(
    flatbuffers::FlatBufferBuilder &_fbb,
    ParcelData parcelData_type = ParcelData_NONE,
    flatbuffers::Offset<void> parcelData = 0) {
  ParcelBuilder builder_(_fbb);
  builder_.add_parcelData(parcelData);
  builder_.add_parcelData_type(parcelData_type);
  return builder_.Finish();
}

inline bool VerifyWorkerRequestData(flatbuffers::Verifier &verifier, const void *obj, WorkerRequestData type) {
  switch (type) {
    case WorkerRequestData_NONE: {
      return true;
    }
    case WorkerRequestData_WorkerConnectRequest: {
      auto ptr = reinterpret_cast<const WorkerConnectRequest *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case WorkerRequestData_WorkerDisconnectRequest: {
      auto ptr = reinterpret_cast<const WorkerDisconnectRequest *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case WorkerRequestData_WorkerGetSceneInfoRequest: {
      auto ptr = reinterpret_cast<const WorkerGetSceneInfoRequest *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case WorkerRequestData_WorkerVerifySceneRequest: {
      auto ptr = reinterpret_cast<const WorkerVerifySceneRequest *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case WorkerRequestData_WorkerGetWorkScopeRequest: {
      auto ptr = reinterpret_cast<const WorkerGetWorkScopeRequest *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case WorkerRequestData_WorkerPublishArtifactsRequest: {
      auto ptr = reinterpret_cast<const WorkerPublishArtifactsRequest *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return false;
  }
}

inline bool VerifyWorkerRequestDataVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyWorkerRequestData(
        verifier,  values->Get(i), types->GetEnum<WorkerRequestData>(i))) {
      return false;
    }
  }
  return true;
}

inline bool VerifyWorkerResponseData(flatbuffers::Verifier &verifier, const void *obj, WorkerResponseData type) {
  switch (type) {
    case WorkerResponseData_NONE: {
      return true;
    }
    case WorkerResponseData_WorkerErrorResponse: {
      auto ptr = reinterpret_cast<const WorkerErrorResponse *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case WorkerResponseData_WorkerConnectResponse: {
      auto ptr = reinterpret_cast<const WorkerConnectResponse *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case WorkerResponseData_WorkerDisconnectResponse: {
      auto ptr = reinterpret_cast<const WorkerDisconnectResponse *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case WorkerResponseData_WorkerGetSceneInfoResponse: {
      auto ptr = reinterpret_cast<const WorkerGetSceneInfoResponse *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case WorkerResponseData_WorkerVerifySceneResponse: {
      auto ptr = reinterpret_cast<const WorkerVerifySceneResponse *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case WorkerResponseData_WorkerGetWorkScopeResponse: {
      auto ptr = reinterpret_cast<const WorkerGetWorkScopeResponse *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case WorkerResponseData_WorkerPublishArtifactsResponse: {
      auto ptr = reinterpret_cast<const WorkerPublishArtifactsResponse *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return false;
  }
}

inline bool VerifyWorkerResponseDataVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyWorkerResponseData(
        verifier,  values->Get(i), types->GetEnum<WorkerResponseData>(i))) {
      return false;
    }
  }
  return true;
}

inline bool VerifyCommanderRequestData(flatbuffers::Verifier &verifier, const void *obj, CommanderRequestData type) {
  switch (type) {
    case CommanderRequestData_NONE: {
      return true;
    }
    case CommanderRequestData_CommanderGetSurfaceInfoRequest: {
      auto ptr = reinterpret_cast<const CommanderGetSurfaceInfoRequest *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case CommanderRequestData_CommanderGetSurfaceRequest: {
      auto ptr = reinterpret_cast<const CommanderGetSurfaceRequest *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return false;
  }
}

inline bool VerifyCommanderRequestDataVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyCommanderRequestData(
        verifier,  values->Get(i), types->GetEnum<CommanderRequestData>(i))) {
      return false;
    }
  }
  return true;
}

inline bool VerifyCommanderResponseData(flatbuffers::Verifier &verifier, const void *obj, CommanderResponseData type) {
  switch (type) {
    case CommanderResponseData_NONE: {
      return true;
    }
    case CommanderResponseData_CommanderGetSurfaceInfoResponse: {
      auto ptr = reinterpret_cast<const CommanderGetSurfaceInfoResponse *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case CommanderResponseData_CommanderGetSurfaceResponse: {
      auto ptr = reinterpret_cast<const CommanderGetSurfaceResponse *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return false;
  }
}

inline bool VerifyCommanderResponseDataVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyCommanderResponseData(
        verifier,  values->Get(i), types->GetEnum<CommanderResponseData>(i))) {
      return false;
    }
  }
  return true;
}

inline bool VerifyParcelData(flatbuffers::Verifier &verifier, const void *obj, ParcelData type) {
  switch (type) {
    case ParcelData_NONE: {
      return true;
    }
    case ParcelData_WorkerRequest: {
      auto ptr = reinterpret_cast<const WorkerRequest *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ParcelData_WorkerResponse: {
      auto ptr = reinterpret_cast<const WorkerResponse *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ParcelData_CommanderRequest: {
      auto ptr = reinterpret_cast<const CommanderRequest *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ParcelData_CommanderResponse: {
      auto ptr = reinterpret_cast<const CommanderResponse *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return false;
  }
}

inline bool VerifyParcelDataVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyParcelData(
        verifier,  values->Get(i), types->GetEnum<ParcelData>(i))) {
      return false;
    }
  }
  return true;
}

}  // namespace DcdrFlatBuffers
}  // namespace Interconnect
}  // namespace Dcdr

#endif  // FLATBUFFERS_GENERATED_DNCP_DCDR_INTERCONNECT_DCDRFLATBUFFERS_H_
